



Java集合是java提供的工具包，包含了常用的数据结构：链表、队列、栈、数组、映射等。Java集合工具包位置是java.util.*
Java集合主要可以划分为4个部分：List列表、Set集合、Map映射、工具类(Iterator迭代器、Enumeration枚举类、Arrays和Collections)

![](E:\ChunBo相关\笔记\08171028-a5e372741b18431591bb577b1e1c95e6.jpg)

1 Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。

  Collection包含了List和Set两大分支。
  (01) List是一个有序的队列，每一个元素都有它的索引。第一个元素的索引值是0。
          List的实现类有LinkedList, ArrayList, Vector, Stack。

  (02) Set是一个不允许有重复元素的集合。
          Set的实现类有HastSet和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。

2 Map是一个映射接口，即key-value键值对。Map中的每一个元素包含“一个key”和“key对应的value”。

   AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。
   Hashtable虽然继承于Dictionary，但它实现了Map接口。

接下来，再看Iterator。它是遍历集合的工具，即我们通常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。
ListIterator是专门为遍历List而存在的。

再看Enumeration，它是JDK 1.0引入的抽象类。作用和Iterator一样，也是遍历集合；但是Enumeration的功能要比Iterator少。在上面的框图中，Enumeration只能在Hashtable, Vector, Stack中使用。

Arrays和Collections 它们是操作数组、集合的两个工具类

# Collection

集合的顶层接口，他本身还继承一个父接口Iterable

```java
public interface Collection<E> extends Iterable<E> {
	int size();
    boolean isEmpty();
    boolean contains(Object o);
    Iterator<E> iterator();
    Object[] toArray();
    <T> T[] toArray(T[] a);
    boolean add(E e);
    boolean remove(Object o);
    boolean containsAll(Collection<?> c);
    boolean addAll(Collection<? extends E> c);
    boolean removeAll(Collection<?> c);
    default boolean removeIf(Predicate<? super E> filter) {// 1.8 如果true 则删除
        Objects.requireNonNull(filter);
        boolean removed = false;
        final Iterator<E> each = iterator();
        while (each.hasNext()) {
            if (filter.test(each.next())) {
                each.remove();
                removed = true;
            }
        }
        return removed;
    }
    boolean retainAll(Collection<?> c);// 保留这些元素
    void clear();// 清空
    boolean equals(Object o);// 必须重写equals方法
    int hashCode();// 必须重写hashCode方法
    default Spliterator<E> spliterator() {
        return Spliterators.spliterator(this, 0);
    }
    default Stream<E> stream() {// stram类，集合的流式操作
        return StreamSupport.stream(spliterator(), false);
    }
    default Stream<E> parallelStream() {// 并行流
        return StreamSupport.stream(spliterator(), true);
    }
}
```

```java
/* @since 1.5
 * @jls 14.14.2 The enhanced for statement
 */
public interface Iterable<T> {
    /**
     * Returns an iterator over elements of type {@code T}.
     *
     * @return an Iterator.
     */
    Iterator<T> iterator();
    /**
     ...
     * @since 1.8
     */
    default void forEach(Consumer<? super T> action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }
    /**
    ...
     * @since 1.8
     */
    default Spliterator<T> spliterator() {
        return Spliterators.spliteratorUnknownSize(iterator(), 0);
    }
```

Collection接口，主要有三个分支：**List** 、**Set**、**Queue**

```java
public interface List<E> extends Collection<E> {
```

```java
public interface Set<E> extends Collection<E> {
```

```java
public interface Queue<E> extends Collection<E> {
```

List和Set都是接口，它们继承于Collection。**List是有序的队列，List中可以有重复的元素**；而**Set是数学概念中的集合，Set中没有重复元素**！

抽象出了AbstractCollection抽象类，它实现了Collection中的绝大部分函数；这样在Collection的实现类中，就可以通过继承AbstractCollection省去重复编码

```java
public abstract class AbstractCollection<E> implements Collection<E> {
```

AbstractList、AbstractSet、AbstractQueue都继承于AbstractCollection

```java
public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {
```

```java
public abstract class AbstractSet<E> extends AbstractCollection<E> implements Set<E> {
```

```java
public abstract class AbstractQueue<E>
    extends AbstractCollection<E>
    implements Queue<E> {
```

具体的List实现类继承AbstractList，Set的实现类则继承AbstractSet，Queue的实现类继承AbstractQueue

ArrayList、LinkedList、Vector、Stack、HashSet、LinkedHashSet、TreeSet、ConcurrentLinkedQueue...

 另外，Collection中有一个iterator()函数，它的作用是返回一个Iterator接口。通常，我们通过Iterator迭代器来遍历集合。ListIterator是List接口所特有的，在List接口中，通过ListIterator()返回一个ListIterator对象

## List

### ArrayList

数组

非线程安全

// List集合，随机访问

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```

ArrayList<Integer> arrayList = new ArrayList();//调用无参构造器

```java
/*源码如下*/
private static final int DEFAULT_CAPACITY = 10;
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
public ArrayList() {
    this.elementData = 		DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
//由此可见，调用无参构造器时，赋值了一个空数组
```

arrayList.add(3);arrayList.add(5);arrayList.add(8);

```java
/*源码如下*/
public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
private void ensureCapacityInternal(int minCapacity) {
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        ensureExplicitCapacity(minCapacity);
}
//调用无参构造器，在第一次add添加元素的时候，minCapacity = 10
private void ensureExplicitCapacity(int minCapacity) {
        modCount++;// 并发计数

        // overflow-conscious code
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }
//size + 1 超出容量，需要扩容
private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
//oldCapacity + (oldCapacity >> 1);数组现有长度 + 右移一位
//右移一位其实就是除2  也就是说 每次扩容为原数组1.5倍的长度
//如10 00001010 >> 1 = 00000101 = 5   newCapacity = 10 + 5 = 15
//如15 00001111 >> 1 = 00000111 = 7   newCapacity = 15 + 7 = 22
//如22 00010110 >> 1 = 00001011 = 11   newCapacity = 22 + 11 = 33
//容量最大值为int的最大值   Arrays.copyOf(elementData, newCapacity);在后续介绍

/*时间复杂度O(1)
由此可见，在初始化ArrayList时如果调用无参构造器，会在添加第一个元素的时候进行数组扩容，进行Arrays.copyOf的操作，所以在创建ArrayList集合时需要给定一个准确或估计值或默认大小10也可以，避免发生拷贝数组的操作*/

public void add(int index, E element) {
        rangeCheckForAdd(index);

        ensureCapacityInternal(size + 1);  // Increments modCount!!
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
        elementData[index] = element;
        size++;
    }
/*指定下标增加，会把原集合index位置后移一位再插入*/
```

arrayList.remove(0);//使用index删除

```java
public E remove(int index) {
        rangeCheck(index);//检查是否下标越界
       	modCount++;//修改占位符
        E oldValue = elementData(index);//返回要被删除的元素
        int numMoved = size - index - 1;//size 10,index 0 
        if (numMoved > 0)
            //把数组index位置至最后用原index+1至最后来替换
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work

        return oldValue;
    }
//src源数组，srcPos源数组起始位置，dest目标数组，destPos目标数组起始位置，length要拷贝的源数组长度
public static native void arraycopy(Object src,  int  srcPos,
                                        Object dest, int destPos,
                                        int length); 

/*时间复杂度O(n)
Arrays.copyOf和System.arraycopy的区别，前者是拷贝一个完整数组，后者是可部分拷贝替换目标数组
返回被删除元素的值
*/
```

arrayList.remove(new Integer(5));//使用obj删除

```java
public boolean remove(Object o) {
        if (o == null) {
            for (int index = 0; index < size; index++)
                if (elementData[index] == null) {
                    fastRemove(index);
                    return true;
                }
        } else {
            for (int index = 0; index < size; index++)
                if (o.equals(elementData[index])) {
                    fastRemove(index);
                    return true;
                }
        }
        return false;
    }
   private void fastRemove(int index) {
        modCount++;
        int numMoved = size - index - 1;
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work
    }    
    
/*时间复杂度O(2n)
先循环找一遍数组所有元素，看哪个是需要删除的元素，再用下标进行拷贝删除 
返回true或false
*/
```

arrayList.set(0,10);

```java
public E set(int index, E element) {
        rangeCheck(index);

        E oldValue = elementData(index);
        elementData[index] = element;
        return oldValue;
    }
/*指定索引进行修改，时间复杂度O(1) 返回old值*/
```

arrayList.get(0);

```java
public E get(int index) {
        rangeCheck(index);

        return elementData(index);
    }
E elementData(int index) {
        return (E) elementData[index];
    }
/*指定索引获取，时间复杂度O(1)*/    
```

##### 常用方法

ArrayList<Integer> arrayList2 = new ArrayList(5);
arrayList2.add(0);arrayList2.add(1);arrayList2.add(2);arrayList2.add(3);

List<Integer> arrayList3 = arrayList2.subList(0,2);

arrayList3 .add(10);

```java
public List<E> subList(int fromIndex, int toIndex) {
        subListRangeCheck(fromIndex, toIndex, size);
        return new SubList(this, 0, fromIndex, toIndex);
    }
private class SubList extends AbstractList<E> implements RandomAccess {
        private final AbstractList<E> parent;
        private final int parentOffset;
        private final int offset;
        int size;
        SubList(AbstractList<E> parent,
                int offset, int fromIndex, int toIndex) {
            this.parent = parent;
            this.parentOffset = fromIndex;
            this.offset = offset + fromIndex;
            this.size = toIndex - fromIndex;
            this.modCount = ArrayList.this.modCount;
        }
        public E set(int index, E e) {
            rangeCheck(index);
            checkForComodification();
            E oldValue = ArrayList.this.elementData(offset + index);
            ArrayList.this.elementData[offset + index] = e;
            return oldValue;
        }
        public E get(int index) {
            rangeCheck(index);
            checkForComodification();
            return ArrayList.this.elementData(offset + index);
        }
        public int size() {
            checkForComodification();
            return this.size;
        }
        public void add(int index, E e) {
            rangeCheckForAdd(index);
            checkForComodification();
            parent.add(parentOffset + index, e);
            this.modCount = parent.modCount;
            this.size++;
        }
        public E remove(int index) {
            rangeCheck(index);
            checkForComodification();
            E result = parent.remove(parentOffset + index);
            this.modCount = parent.modCount;
            this.size--;
            return result;
        }
		.......
        public boolean addAll(Collection<? extends E> c) {
            return addAll(this.size, c);
        }
        public boolean addAll(int index, Collection<? extends E> c) {
            rangeCheckForAdd(index);
            int cSize = c.size();
            if (cSize==0)
                return false;
            checkForComodification();
            parent.addAll(parentOffset + index, c);
            this.modCount = parent.modCount;
            this.size += cSize;
            return true;
        }
        public Iterator<E> iterator() {
            return listIterator();
        }
        public ListIterator<E> listIterator(final int index) {
            checkForComodification();
            rangeCheckForAdd(index);
            final int offset = this.offset;
            return new ListIterator<E>() {
                int cursor = index;
                int lastRet = -1;
                int expectedModCount = ArrayList.this.modCount;
                public boolean hasNext() {
                    return cursor != SubList.this.size;
                }
                @SuppressWarnings("unchecked")
                public E next() {
                    checkForComodification();
                    int i = cursor;
                    if (i >= SubList.this.size)
                        throw new NoSuchElementException();
                    Object[] elementData = ArrayList.this.elementData;
                    if (offset + i >= elementData.length)
                        throw new ConcurrentModificationException();
                    cursor = i + 1;
                    return (E) elementData[offset + (lastRet = i)];
                }
                .......
                public void remove() {
                    if (lastRet < 0)
                        throw new IllegalStateException();
                    checkForComodification();

                    try {
                        SubList.this.remove(lastRet);
                        cursor = lastRet;
                        lastRet = -1;
                        expectedModCount = ArrayList.this.modCount;
                    } catch (IndexOutOfBoundsException ex) {
                        throw new ConcurrentModificationException();
                    }
                }
                public void set(E e) {
                    if (lastRet < 0)
                        throw new IllegalStateException();
                    checkForComodification();
                    try {
                        ArrayList.this.set(offset + lastRet, e);
                    } catch (IndexOutOfBoundsException ex) {
                        throw new ConcurrentModificationException();
                    }
                }

                public void add(E e) {
                    checkForComodification();
                    try {
                        int i = cursor;
                        SubList.this.add(i, e);
                        cursor = i + 1;
                        lastRet = -1;
                        expectedModCount = ArrayList.this.modCount;
                    } catch (IndexOutOfBoundsException ex) {
                        throw new ConcurrentModificationException();
                    }
                }
            };
        }
        public List<E> subList(int fromIndex, int toIndex) {
            subListRangeCheck(fromIndex, toIndex, size);
            return new SubList(this, offset, fromIndex, toIndex);
        }
		.............
    }
/*注意：arrayList2.subList(0,2)，其实就是new SubList(this, 0, fromIndex, toIndex);操作
SubList类只是记录了原集合的下标需要被截取的下标起始值，所有的增删改查操作还是基于原集合进行操作，如：arrayList3 .add(10);后
AbstractList.java#add(e)
public boolean add(E e) {
        add(size(), e);
        return true;
    }
subList.add(size(), e);  parent.add(size(), e);  
此时如果遍历arrayList2，下标2的位置会变为10
会存在问题就是，即使我只想对arrayList3进行add(e)操作，但其实对于原集合是进行add(index,e)操作，这样一来每次add都会进行System.arraycopy(elementData, index, elementData, index + 1,
                         size - index); 性能下降
*/
```

##### java8新增

ArrayList<Integer> arrayList2 = new ArrayList(5);
arrayList2.add(0);arrayList2.add(1);arrayList2.add(2);arrayList2.add(3);

arrayList2.forEach(s->System.out.println(s));

arrayList2.forEach(System.out::println);

循环遍历操作，需要传一个consumer

```java
@Override
    public void forEach(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        final int expectedModCount = modCount;
        @SuppressWarnings("unchecked")
        final E[] elementData = (E[]) this.elementData;
        final int size = this.size;
        for (int i=0; modCount == expectedModCount && i < size; i++) {
            action.accept(elementData[i]);
        }
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
    }
```

arrayList2.removeIf(t -> t % 2 != 0);

需要传一个Predicate，消费元素返回true或false，如果满足Predicate.test()则删除

```java
@Override
    public boolean removeIf(Predicate<? super E> filter) {
        Objects.requireNonNull(filter);
        // figure out which elements are to be removed
        // any exception thrown from the filter predicate at this stage
        // will leave the collection unmodified
        int removeCount = 0;
        final BitSet removeSet = new BitSet(size);
        final int expectedModCount = modCount;
        final int size = this.size;
        for (int i=0; modCount == expectedModCount && i < size; i++) {
            @SuppressWarnings("unchecked")
            final E element = (E) elementData[i];
            if (filter.test(element)) {
                removeSet.set(i);
                removeCount++;
            }
        }
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }

        // shift surviving elements left over the spaces left by removed elements
        final boolean anyToRemove = removeCount > 0;
        if (anyToRemove) {
            final int newSize = size - removeCount;
            for (int i=0, j=0; (i < size) && (j < newSize); i++, j++) {
                i = removeSet.nextClearBit(i);
                elementData[j] = elementData[i];
            }
            for (int k=newSize; k < size; k++) {
                elementData[k] = null;  // Let gc do its work
            }
            this.size = newSize;
            if (modCount != expectedModCount) {
                throw new ConcurrentModificationException();
            }
            modCount++;
        }

        return anyToRemove;
    }
```

arrayList2.replaceAll( t -> t + 10 );

需要传一个UnaryOperator，UnaryOperator是Function的子类，传入的是apply()方法

```
public void replaceAll(UnaryOperator<E> operator) {
        Objects.requireNonNull(operator);
        final int expectedModCount = modCount;
        final int size = this.size;
        for (int i=0; modCount == expectedModCount && i < size; i++) {
            elementData[i] = operator.apply((E) elementData[i]);
        }
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
        modCount++;
    }
```

### Vector

// List集合，随机访问

```java
public class Vector<E>
    extends AbstractList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable{
```

线程安全

几乎所有功能与ArrayList一致，所有功能全部synchronized线程安全的

### Stack

```java
public
class Stack<E> extends Vector<E> {
```

线程安全

继承自Vector，可访问Vector方法，如add、get等

栈利用数组结构，查看或取出顶端元素，如方法调用栈，网页回退等

栈只提供了无参构造器

Stack<Integer> stack = new Stack();

```java
public Stack() {
}
//默认第一次添加元素时，数组扩容
```

stack.push(10);stack.push(11);stack.push(12);

```java
public E push(E item) {
    addElement(item);

    return item;
}
//push操作都插到数组末尾
```

stack.peek();

```java
public synchronized E peek() {
    int     len = size();

    if (len == 0)
        throw new EmptyStackException();
    return elementAt(len - 1);
}
//peek操作取出最顶端元素查看，也就是数组末尾元素
```

stack.pop();

```java
public synchronized E pop() {
    E       obj;
    int     len = size();

    obj = peek();
    removeElementAt(len - 1);

    return obj;
}
//pop取出顶端元素并删除
```

stack.search(11);

```java
public synchronized int search(Object o) {
    int i = lastIndexOf(o);

    if (i >= 0) {
        return size() - i;
    }
    return -1;
}
//search查看所元素下标
```

### LinkedList

非线程安全，链表结构

实现List接口

List<Integer> list = new LinkedList<>();

// 双端队列，List集合

```java
public class LinkedList<E>
    extends AbstractSequentialList<E>
    implements List<E>, Deque<E>, Cloneable, java.io.Serializable
{
transient Node<E> first;
transient Node<E> last;
```

```java
private static class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
```

list.add(10);list.add(11);list.add(12);//链尾插入

```java
public boolean add(E e) {
        linkLast(e);
        return true;
    }
void linkLast(E e) {
        final Node<E> l = last;
        final Node<E> newNode = new Node<>(l, e, null);
        last = newNode;
        if (l == null)
            first = newNode;
        else
            l.next = newNode;
        size++;
        modCount++;
    }    
//时间复杂度O(1)
```

list.add(1,13);//指定下标插入

```java
public void add(int index, E element) {
        checkPositionIndex(index);

        if (index == size)
            linkLast(element);//看上面
        else
            linkBefore(element, node(index));//node()方法看下面
    }
//时间复杂度O(n / 2)
```

```java
void linkBefore(E e, Node<E> succ) {
        // assert succ != null;
        final Node<E> pred = succ.prev;
        final Node<E> newNode = new Node<>(pred, e, succ);
        succ.prev = newNode;
        if (pred == null)
            first = newNode;
        else
            pred.next = newNode;
        size++;
        modCount++;
    }
```

list.set(1,111);

```java
public E set(int index, E element) {
        checkElementIndex(index);
        Node<E> x = node(index);
        E oldVal = x.item;
        x.item = element;
        return oldVal;
    }
//时间复杂度O(n / 2)
```

```java
Node<E> node(int index) {
        // assert isElementIndex(index);
		//长度右移一位 就是除2 只找半区
        if (index < (size >> 1)) {
            Node<E> x = first;
            for (int i = 0; i < index; i++)
                x = x.next;
            return x;
        } else {
            Node<E> x = last;
            for (int i = size - 1; i > index; i--)
                x = x.prev;
            return x;
        }
    }  
```

list.remove(1);//下标删

```java
public E remove(int index) {
    checkElementIndex(index);
    return unlink(node(index));
}
E unlink(Node<E> x) {
        // assert x != null;
        final E element = x.item;
        final Node<E> next = x.next;
        final Node<E> prev = x.prev;

        if (prev == null) {
            first = next;
        } else {
            prev.next = next;
            x.prev = null;
        }

        if (next == null) {
            last = prev;
        } else {
            next.prev = prev;
            x.next = null;
        }

        x.item = null;
        size--;
        modCount++;
        return element;
    }
```



## Map

### Hash算法

1.hash算法的计算

```
一个散列性好的hash算法，计算出的hash值，映射到每一个属性值的概率是近似的。
1.最好每一个属性都参与计算
2.
2.1计算所使用的数值最好是素数（除了1和它本身以外不再有其他因数）如：13、17、31、37，这个是被科学家论证过的hash函数减少冲突的一个理论。
2.2如果设置为偶数的话会存在溢出的情况，导致信息丢失（因为使用偶数相当于使用了移位运算）
2.3可以兼顾到虚拟机的性能，虚拟机默认使用2<<5-1 来的到很好的性能，且其是一个不大不小的质数，兼顾了性能和冲突率
```

如果重写Object类的hash算法，可以参考String类

```java
public int hashCode() {
    int h = hash;
    if (h == 0 && value.length > 0) {
        char val[] = value;

        for (int i = 0; i < value.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;
    }
    return h;
}
```

2.hash冲突的解决算法

```
1.链地址法
对于相同的哈希值，使用链表进行连接。（HashMap使用此法）
优点: 1）处理冲突简单，无堆积现象。即非同义词决不会发生冲突，因此平均查找长度较短；
	 2）适合总数经常变化的情况。（因为拉链法中各链表上的结点空间是动态申请的）
	 3）占空间小。装填因子可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计
	 4）删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。
缺点：1）查询时效率较低。（存储是动态的，查询时跳转需要更多的时间）
	 2）在key-value可以预知，以及没有后续增改操作时候，开放定址法性能优于链地址法。
	 3）不容易序列化
	 
2.开放寻址法
当关键字key的哈希地址p=Hash(key)出现冲突时，以p为基础，产生另一个哈希地址p1，若p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。
开放定址法有下边三种方式：
    1）线性探测再散列：顺序查看下一个单元，直到找出一个空单元或查遍全表。（ThreadLocal）
	2）二次(平方)探测再散列：在表的左右进行跳跃式探测，直到找出一个空单元或查遍全表。
	3）伪随机探测再散列：建立一个伪随机数发生器，并给一个随机数作为起点。

3.再哈希法
提供多个哈希函数，如果第一个哈希函数计算出来的key的哈希值冲突了，则使用第二个哈希函数计算key的哈希值。
优点：1）不易产生聚集
缺点：1）增加了计算时间

4.建立公共溢出区
将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。
```

### HashMap

JDK1.8涉及的数据结构有hash表、链表、红黑树

一些阈值

```
默认容量：int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
最大容量：int MAXIMUM_CAPACITY = 1 << 30;// aka 1073741824
负载因子、扩容因子：float DEFAULT_LOAD_FACTOR = 0.75f; // 太小扩容频繁浪费空间。太大hash冲突过多
链表转红黑树链表长度阈值：int TREEIFY_THRESHOLD = 8; // log以2为底8的对数为3
链表转红黑树hash表最小长度：int MIN_TREEIFY_CAPACITY = 64; // 避免数组容量太小导致的hash冲突太多
红黑树退化链表阈值：int UNTREEIFY_THRESHOLD = 6;
```

#### 确定元素在hash表的位置

hashMap中的hash方法，通过我们的hash值，再次确认key在hash表的位置

##### hash(object);

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);

1.首先可以看出，hashmap的key可以为null

2.key.hashCode要和自身的高16位进行异或运算。目的是为了增加散列性，如果hashcode值为[456, 123456. 456456] % 15 都等于6，但如果高16位参与运算，冲突就会大大减小。

tab.length = 16 tab.length - 1 = 15; hash = 78897121 

00000000 00000000 00000000  00001111

&

00000100 10110011 11011111 11100001

由于hashcode要和（length-1）进行取模运算（&），length 绝大多数情况小于2的16次方。所以始终是hashcode 的低16位（甚至更低）参与运算。要是高16位也参与运算，会让得到的下标更加散列。

**key的hashcode()高16位和低16位为什么用^而不用&和|**
^异或运算，一真一假为真，同真同假为假，真假概率均为1/2，结果均衡

|或运算，一真为真，真的概率为3/4，运算结果向真靠拢

&与运算，一假为假，假的概率为3/4，运算结果向假靠拢

##### tab[(tab.length - 1) & hash]

为什么使用与&运算，而不是取模运算。

1.首先，只要保持tab的长度是2的次幂，那么与运算和取模运算的结果就是一致的。

00001111

00001010

00001010

10 % 15 = 10

2.与&运算是二进制运算，可以直接操作。而取模操作需要转化为十进制。

所以尽可能使用位运算。

#### put(K key, V value);

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
```

```java
/**
     * Implements Map.put and related methods
     *
     * @param hash hash for key
     * @param key the key
     * @param value the value to put
     * @param onlyIfAbsent if true, don't change existing value
     * @param evict if false, the table is in creation mode.
     * @return previous value, or null if none
     */
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;//标记1。如果table没有初始化要进行一次resize()扩容操作，我们后续在看
    if ((p = tab[i = (n - 1) & hash]) == null)// 当前hash表的位置没有冲突
        tab[i] = newNode(hash, key, value, null);// 当前位置放置节点
    else {// 如果出现了hash冲突 要排入链表或者红黑树
        Node<K,V> e; K k;
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))// 如果hash相等并且key也相等，说明本次操作的就是头结点的修改操作
            e = p;
        else if (p instanceof TreeNode)//标记2。如果当前冲突的头结点是红黑树类型，那么要以树的方式添加
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else { // 链表
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {// 遍历当前hash位置的整张链表结束，在最后添加新元素
                    p.next = newNode(hash, key, value, null);
                    if (binCount >= TREEIFY_THRESHOLD - 1) //标记3。-1for1st链表长度大于8，转红黑树
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key 修改操作
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;// 修改操作返回旧的值
        }
    }
    ++modCount;
    if (++size > threshold)
        resize();// 扩容
    afterNodeInsertion(evict);
    return null;// 新增操作返回null
}
```

```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next;
```

```java
static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
    TreeNode<K,V> parent;  // red-black tree links
    TreeNode<K,V> left;
    TreeNode<K,V> right;
    TreeNode<K,V> prev;    // needed to unlink next upon deletion
    boolean red;
    TreeNode(int hash, K key, V val, Node<K,V> next) {
        super(hash, key, val, next);
    }
```

```java
static class LinkedHashMap.Entry<K,V> extends HashMap.Node<K,V> {
    Entry<K,V> before, after;
```

treeifyBin(tab, hash);

```java
/**
 * Replaces all linked nodes in bin at index for given hash unless
 * table is too small, in which case resizes instead.
 */
final void treeifyBin(Node<K,V>[] tab, int hash) {
    int n, index; Node<K,V> e;
    // 如果数组长度小于64，扩容
    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
        resize();
    else if ((e = tab[index = (n - 1) & hash]) != null) {
        TreeNode<K,V> hd = null, tl = null;
        do {
            TreeNode<K,V> p = replacementTreeNode(e, null);
            if (tl == null)
                hd = p;
            else {
                p.prev = tl;
                tl.next = p;
            }
            tl = p;
        } while ((e = e.next) != null);
        if ((tab[index] = hd) != null)
            hd.treeify(tab);
    }
}
```



标记1 扩容 当第一次进行put操作时，才会初始化hash表

#### reresize()

```java
/**
 * Initializes or doubles table size.  If null, allocates in
 * accord with initial capacity target held in field threshold.
 * Otherwise, because we are using power-of-two expansion, the
 * elements from each bin must either stay at same index, or move
 * with a power of two offset in the new table.
 *
 * @return the table
 */
final Node<K,V>[] resize() {
    Node<K,V>[] oldTab = table;// 旧hash表
    int oldCap = (oldTab == null) ? 0 : oldTab.length;// 旧hash表容量
    int oldThr = threshold;// 旧的扩容的阀值
    int newCap, newThr = 0;// 新的hash表容量和新的扩容的阀值
    if (oldCap > 0) {// 说明不是初始的扩容
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        // 有符号左移一位 扩容一倍 *2
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                 oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1; // double threshold
    }
    else if (oldThr > 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else {               // zero initial threshold signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({"rawtypes","unchecked"})
        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    table = newTab;
    if (oldTab != null) { // copy到新hash表
        for (int j = 0; j < oldCap; ++j) {
            Node<K,V> e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;
                if (e.next == null)// 没有冲突 直接hash到新表
                    newTab[e.hash & (newCap - 1)] = e;
                else if (e instanceof TreeNode)// 标记1.1。拆树
                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                else { // preserve order 链表保存顺序
                    Node<K,V> loHead = null, loTail = null;// 新hash表低位
                    Node<K,V> hiHead = null, hiTail = null;// 新hash表高位
                    Node<K,V> next;
                    do {
                        next = e.next;
                        /**
                        * 与的不是length - 1，而是length
                        * 假如此时length也就是oldCap为16，e.hash和16二进制相与是否得0，也就是使用						 * 倒数第5位，理想情况概率为1/2，链表一分为二。
                        */ 
                        if ((e.hash & oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);// 遍历整个链表
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;// 将低位链表装载至新的hash表低位
                    }
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;// 将高位链表装载至新的hash表高位
                    }
                }
            }
        }
    }
    return newTab;
}
```

##### split(map, newTab, index, int oldCap)拆树

```java
/**
 * Splits nodes in a tree bin into lower and upper tree bins,
 * or untreeifies if now too small. Called only from resize;
 * see above discussion about split bits and indices.
 *
 * @param map the map
 * @param tab the table for recording bin heads
 * @param index the index of the table being split
 * @param bit the bit of hash to split on
 */
final void split(HashMap<K,V> map, Node<K,V>[] tab, int index, int bit) {
    TreeNode<K,V> b = this;// 数组节点，也是树的根节点
    // Relink into lo and hi lists, preserving order
    TreeNode<K,V> loHead = null, loTail = null;
    TreeNode<K,V> hiHead = null, hiTail = null;
    int lc = 0, hc = 0;// 分别记录高低位的数量
    // 遍历红黑树，因为树节点继承了Node节点，所以是树也是链表
    for (TreeNode<K,V> e = b, next; e != null; e = next) {
        next = (TreeNode<K,V>)e.next;
        e.next = null;// gc
        // 同拆链表，与上旧数组的长度，同样是1/2概率
        if ((e.hash & bit) == 0) {// 新hash表低位
            if ((e.prev = loTail) == null)
                loHead = e;
            else
                loTail.next = e;
            loTail = e;
            ++lc;
        }
        else {// 新hash表高位
            if ((e.prev = hiTail) == null)
                hiHead = e;
            else
                hiTail.next = e;
            hiTail = e;
            ++hc;
        }
    }

    if (loHead != null) {
        if (lc <= UNTREEIFY_THRESHOLD)// 如果小于等于6，树拆成链表
            tab[index] = loHead.untreeify(map);// 新表中将低位链表化
        else {// 还保持红黑树
            tab[index] = loHead;
            // 除了低位，高位还有元素，需要从当前头节点开始树化
            if (hiHead != null) // (else is already treeified)
                loHead.treeify(tab);// 新表中将低位需要重新树化
        }
    }
    if (hiHead != null) {
        if (hc <= UNTREEIFY_THRESHOLD)
            tab[index + bit] = hiHead.untreeify(map);
        else {
            tab[index + bit] = hiHead;
            if (loHead != null)
                hiHead.treeify(tab);
        }
    }
}
```

#### 面试常问总结概述

```
hashmap的put方法
1.通过hash方法计算hash值
	1.1 key如果为空hash值则为0
	1.2 否则取key的hashcode()，使hashcode()高16位与低16位相异或，为什么？
		hashcode()值与长度做取模运算，但大多数情况下，hash表数组长度相比于hashcode()值要小很多，也就是，只有低位数字可以参与其中计算，高位数字无法参与。
		所以使用int型4字节32位中，高16位与低16位相异或。那为什么这个位运算要用异或^，而不是与&和或|呢？
		两二进制位进行位运算，情况有4种：A真1 B真1、A真1 B假0、A假0 B真1、A假0 B假0
		与运算只有AB都为真结果才为真，也就是真的结果为1/4，假的结果为3/4，结果更趋近于假
		或运算只有AB都为假结果才为假，也就是假的结果为1/4，真的结果为3/4，结果更趋近于真
		异或运算一真一假则为真 两真两假都为假，真的结果为2/4，假的结果也为2/4，结果更加均衡
2.如果hashtable没有初始化，则需要第一次resize初始化，默认长度为16，扩容因子为0.75（太小则浪费空间，太大则hash冲突概率会变大）
3.通过上面计算出的hash值，和数组长度进行取模操作，决定元素所在数组的位置，但这里使用的是length-1与&运算，而不是取模运算，为什么？
						  如果长度是2的次幂，他-1后的二进制与hash值做与运算，和取模运算的结果是一致的
						  与运算要比取模运算效率高1.3倍以上，因为cpu是二进制计算，位运算可以直接使用，而十进制需要转化为二进制后计算
4.确定元素在数组的位置后，tab[i]如果为空，则没有出现hash冲突，直接new一个Node节点插入
5.如果出现hash冲突
	5.1 判断头节点的key值和当前put元素的key值是否equals，如果相等，则说明是修改操作
	5.2 如果当前节点已经是树化了，从跟节点遍历红黑树，进行插入或修改操作
	5.3 如果仍是链表节点，从头节点遍历红黑树，进行插入或修改操作。
		如果插入后，链表的长度大于等于8了，需要判断当前数组的长度是否小于64
			5.3.1 如果小于64，需要进行扩容操作。为什么？因为数组长度过小的时候，hash冲突会多，所以先进行扩容
			5.3.2 如果大于等于64，进行链表转红黑树。链表长度小于等于6的时候，还会拆树为链表
6.如果长度没有大于扩容因子 * 长度 = 12，则结束。否则进行扩容操作
  6.1 先将数组长度左移一位，也就是乘2，创建一个两倍长的数组
  6.2 遍历旧数组
		6.2.1 如果当前旧数组遍历的节点为空则不操作
		6.2.2 如果当前数组位只有一个节点，则使用新table长度进行取模运算newTab[e.hash & (newCap - 1)]
		6.2.3 如果是链表节点，遍历整张链表，通过oldcap(16) & e.hash算法来将原链条切割，结果为0的放置新数组的低位(旧数组下标)，结果为1的放置新数组的高位(旧数组下标 + oldcap)，理想情况下均分为2
		6.2.4 如果已经树化，遍历树节点，由于树节点继承自链表节点，所以也可以通过next引用遍历。同链表节点一样
			  通过oldcap(16) & e.hash算法来将原链条切割，结果为0的放置新数组的低位(旧数组下标)，结果为1的放置新数组的高位(旧数组下标 + oldcap)，理想情况下均分为2
			  6.2.4.1 如果高低位的链条长度小于等于6，把链条的树TreeNode节点转化为链条Node节点
			  6.2.4.2 如果高低位的链条长度大于6，说明还需要维持树的结构。
					  低位时，需要判断高位链条是否有元素，如果没有，说明当前低位就已经是一颗完整的树了，不需要转化、如果有，则转化为树。
					  高位亦然
```

### LinkedHashMap

由于增加了双向链表结构，可以保存插入时的顺序，遍历时会按照插入时顺序遍历。HashMap遍历是无序的

遍历的速度要比HashMap快，但是put时,增加了保存链表的操作，会慢一些，Node节点也增加了存储空间，多了before，after两个引用的存储

如果存储时需要保证存储顺序，或者需要把已经访问过的元素放入尾部，也就是优先访问未访问过的元素时，使用LinkedHashMap

```java
public class LinkedHashMap<K,V>
    extends HashMap<K,V>
    implements Map<K,V>
{
/**
     * The head (eldest) of the doubly linked list.
     */
    transient LinkedHashMap.Entry<K,V> head;
    /**
     * The tail (youngest) of the doubly linked list.
     */
    transient LinkedHashMap.Entry<K,V> tail;
    /**
     * The iteration ordering method for this linked hash map: <tt>true</tt>
     * for access-order, <tt>false</tt> for insertion-order.
     * @serial
     */
    final boolean accessOrder;// 默认false，为true时被访问过的元素要被移步至链表尾部

	static class Entry<K,V> extends HashMap.Node<K,V> {
        Entry<K,V> before, after;
        Entry(int hash, K key, V value, Node<K,V> next) {
            super(hash, key, value, next);
        }
    }
}
```

put操作还是调用父类HashMap的，但是重写了创建新节点时的newNode、newTreeNode方法

```java
Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {
    LinkedHashMap.Entry<K,V> p =
        new LinkedHashMap.Entry<K,V>(hash, key, value, e);
    linkNodeLast(p);
    return p;
}
TreeNode<K,V> newTreeNode(int hash, K key, V value, Node<K,V> next) {
    TreeNode<K,V> p = new TreeNode<K,V>(hash, key, value, next);
    linkNodeLast(p);
    return p;
}
// 插入到tail
private void linkNodeLast(LinkedHashMap.Entry<K,V> p) {
    LinkedHashMap.Entry<K,V> last = tail;
    tail = p;
    if (last == null)
        head = p;
    else {
        p.before = last;
        last.after = p;
    }
}
```

### TreeMap

数据结构是红黑树，所有操作时间复杂度O(log(n))

```java
public class TreeMap<K,V>
    extends AbstractMap<K,V>
    implements NavigableMap<K,V>, Cloneable, java.io.Serializable
{
	private final Comparator<? super K> comparator;// key的比较器，如果为空，那么put()时会强转key为(Comparable<? super K>) key;，如果key不是Comparable的实现类，那么会抛类转换异常
    private transient Entry<K,V> root;// 红黑树根节点
    public TreeMap() {
        comparator = null;
    }
    public TreeMap(Comparator<? super K> comparator) {
        this.comparator = comparator;
    }
```

```java
static final class Entry<K,V> implements Map.Entry<K,V> {
    K key;
    V value;
    Entry<K,V> left;
    Entry<K,V> right;
    Entry<K,V> parent;
    boolean color = BLACK;
    Entry(K key, V value, Entry<K,V> parent) {
        this.key = key;
        this.value = value;
        this.parent = parent;
    }
	...
}
```

get(Object key);// 红黑树，二叉查找树，左子节点key一定小于当前节点，右子节点key一定大于当前节点

```java
public V get(Object key) {
    Entry<K,V> p = getEntry(key);
    return (p==null ? null : p.value);
}
final Entry<K,V> getEntry(Object key) {
    // Offload comparator-based version for sake of performance
    if (comparator != null)
        return getEntryUsingComparator(key);
    if (key == null)
        throw new NullPointerException();
    @SuppressWarnings("unchecked")
    Comparable<? super K> k = (Comparable<? super K>) key;
    Entry<K,V> p = root;
    while (p != null) {
        int cmp = k.compareTo(p.key);
        if (cmp < 0)
            p = p.left;
        else if (cmp > 0)
            p = p.right;
        else
            return p;
    }
    return null;
}
```

put();

```java
public V put(K key, V value) {
    Entry<K,V> t = root;
    if (t == null) {
        compare(key, key); // type (and possibly null) check

        root = new Entry<>(key, value, null);
        size = 1;
        modCount++;
        return null;
    }
    int cmp;
    Entry<K,V> parent;
    // split comparator and comparable paths
    Comparator<? super K> cpr = comparator;
    if (cpr != null) { // 有构造传入的Comparator
        do {
            parent = t;
            cmp = cpr.compare(key, t.key);
            if (cmp < 0)
                t = t.left;
            else if (cmp > 0)
                t = t.right;
            else
                return t.setValue(value);// 发现key相等 修改操作
        } while (t != null);
    }
    else { // 使用key实现的Comparator的compare方法
        if (key == null) // key不允许为空
            throw new NullPointerException();
        @SuppressWarnings("unchecked")
       
            Comparable<? super K> k = (Comparable<? super K>) key;
        do {
            parent = t;
            cmp = k.compareTo(t.key);
            if (cmp < 0)
                t = t.left;
            else if (cmp > 0)
                t = t.right;
            else
                return t.setValue(value);
        } while (t != null);
    }
    Entry<K,V> e = new Entry<>(key, value, parent);// new 一个新节点
    if (cmp < 0)
        parent.left = e;
    else
        parent.right = e;
    fixAfterInsertion(e); // 固定树
    size++;
    modCount++;
    return null;
}
// 需要时调整树，保证红黑树规则
private void fixAfterInsertion(Entry<K,V> x) {
    x.color = RED;

    while (x != null && x != root && x.parent.color == RED) {
        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
            Entry<K,V> y = rightOf(parentOf(parentOf(x)));
            if (colorOf(y) == RED) {
                setColor(parentOf(x), BLACK);
                setColor(y, BLACK);
                setColor(parentOf(parentOf(x)), RED);
                x = parentOf(parentOf(x));
            } else {
                if (x == rightOf(parentOf(x))) {
                    x = parentOf(x);
                    rotateLeft(x);
                }
                setColor(parentOf(x), BLACK);
                setColor(parentOf(parentOf(x)), RED);
                rotateRight(parentOf(parentOf(x)));
            }
        } else {
            Entry<K,V> y = leftOf(parentOf(parentOf(x)));
            if (colorOf(y) == RED) {
                setColor(parentOf(x), BLACK);
                setColor(y, BLACK);
                setColor(parentOf(parentOf(x)), RED);
                x = parentOf(parentOf(x));
            } else {
                if (x == leftOf(parentOf(x))) {
                    x = parentOf(x);
                    rotateRight(x);
                }
                setColor(parentOf(x), BLACK);
                setColor(parentOf(parentOf(x)), RED);
                rotateLeft(parentOf(parentOf(x)));
            }
        }
    }
    root.color = BLACK;
}
```

remove();

```java
public V remove(Object key) {
    Entry<K,V> p = getEntry(key);
    if (p == null)
        return null;

    V oldValue = p.value;
    deleteEntry(p);
    return oldValue;
}
/**
 * Delete node p, and then rebalance the tree.
 */
private void deleteEntry(Entry<K,V> p) {
    modCount++;
    size--;

    // If strictly internal, copy successor's element to p and then make p
    // point to successor.
    if (p.left != null && p.right != null) {
        Entry<K,V> s = successor(p);
        p.key = s.key;
        p.value = s.value;
        p = s;
    } // p has 2 children

    // Start fixup at replacement node, if it exists.
    Entry<K,V> replacement = (p.left != null ? p.left : p.right);

    if (replacement != null) {
        // Link replacement to parent
        replacement.parent = p.parent;
        if (p.parent == null)
            root = replacement;
        else if (p == p.parent.left)
            p.parent.left  = replacement;
        else
            p.parent.right = replacement;

        // Null out links so they are OK to use by fixAfterDeletion.
        p.left = p.right = p.parent = null;

        // Fix replacement
        if (p.color == BLACK)
            fixAfterDeletion(replacement);
    } else if (p.parent == null) { // return if we are the only node.
        root = null;
    } else { //  No children. Use self as phantom replacement and unlink.
        if (p.color == BLACK)
            fixAfterDeletion(p);

        if (p.parent != null) {
            if (p == p.parent.left)
                p.parent.left = null;
            else if (p == p.parent.right)
                p.parent.right = null;
            p.parent = null;
        }
    }
}
/** From CLR */
private void fixAfterDeletion(Entry<K,V> x) {
    while (x != root && colorOf(x) == BLACK) {
        if (x == leftOf(parentOf(x))) {
            Entry<K,V> sib = rightOf(parentOf(x));

            if (colorOf(sib) == RED) {
                setColor(sib, BLACK);
                setColor(parentOf(x), RED);
                rotateLeft(parentOf(x));
                sib = rightOf(parentOf(x));
            }

            if (colorOf(leftOf(sib))  == BLACK &&
                colorOf(rightOf(sib)) == BLACK) {
                setColor(sib, RED);
                x = parentOf(x);
            } else {
                if (colorOf(rightOf(sib)) == BLACK) {
                    setColor(leftOf(sib), BLACK);
                    setColor(sib, RED);
                    rotateRight(sib);
                    sib = rightOf(parentOf(x));
                }
                setColor(sib, colorOf(parentOf(x)));
                setColor(parentOf(x), BLACK);
                setColor(rightOf(sib), BLACK);
                rotateLeft(parentOf(x));
                x = root;
            }
        } else { // symmetric
            Entry<K,V> sib = leftOf(parentOf(x));

            if (colorOf(sib) == RED) {
                setColor(sib, BLACK);
                setColor(parentOf(x), RED);
                rotateRight(parentOf(x));
                sib = leftOf(parentOf(x));
            }

            if (colorOf(rightOf(sib)) == BLACK &&
                colorOf(leftOf(sib)) == BLACK) {
                setColor(sib, RED);
                x = parentOf(x);
            } else {
                if (colorOf(leftOf(sib)) == BLACK) {
                    setColor(rightOf(sib), BLACK);
                    setColor(sib, RED);
                    rotateLeft(sib);
                    sib = leftOf(parentOf(x));
                }
                setColor(sib, colorOf(parentOf(x)));
                setColor(parentOf(x), BLACK);
                setColor(leftOf(sib), BLACK);
                rotateRight(parentOf(x));
                x = root;
            }
        }
    }

    setColor(x, BLACK);
}
```



## Set

set系列集合的目标是 不能存储重复元素，底层实现都是借助Map的key必须唯一来实现的

set集合没有get()方法，只能遍历访问元素

### HashSet

```java
public class HashSet<E>
    extends AbstractSet<E>
    implements Set<E>, Cloneable, java.io.Serializable
{
    static final long serialVersionUID = -5024744406713321676L;

    private transient HashMap<E,Object> map;

	// 虚拟值
    // Dummy value to associate with an Object in the backing Map
    private static final Object PRESENT = new Object();
    
    // 目前专门为LinkedHashSet使用
    HashSet(int initialCapacity, float loadFactor, boolean dummy) {
        map = new LinkedHashMap<>(initialCapacity, loadFactor);
    }
```

add();

```java
public boolean add(E e) {
    return map.put(e, PRESENT)==null; // 把map的key作为Set集合的element存储
}
```

remove();

```java
public boolean remove(Object o) {
    return map.remove(o)==PRESENT;
}
```

测试 

```java
HashSet<Demo> set = new HashSet();
set.add(new Demo(1, "张三"));
set.add(new Demo(2, "李四"));
set.add(new Demo(1, "张三"));
System.out.println(set.size());  // 2

// HashMap中首先会计算key的hash值 由于hashcode方法已重写，所以1、3操作hash值相等
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node<K,V> e; K k;
            // hash值相等 p.key要与key相等说明是同一个key，不等则判断equals方法
            // 这就是为什么 第一次学java时伟俊一直强调，必须重写hashcode和equals方法
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    // 同上
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
```

### LinkedHashSet

继承自HashSet

构造都调用HashSet的map = new LinkedHashMap<>构造

也就是说 LinkedHashSet保证了元素存储的顺序

```java
HashSet(int initialCapacity, float loadFactor, boolean dummy) {
    map = new LinkedHashMap<>(initialCapacity, loadFactor);
}
```

```java
public class LinkedHashSet<E>
    extends HashSet<E>
    implements Set<E>, Cloneable, java.io.Serializable {
    public LinkedHashSet(int initialCapacity, float loadFactor) {
        super(initialCapacity, loadFactor, true);
    }
    public LinkedHashSet(int initialCapacity) {
        super(initialCapacity, .75f, true);
    }
    public LinkedHashSet() {
        super(16, .75f, true);
    }
    
```



### TreeSet

底层是TreeMap，同理，使用自然排序或者自定义排序

```java
public class TreeSet<E> extends AbstractSet<E>
    implements NavigableSet<E>, Cloneable, java.io.Serializable
{
    /**
     * The backing map.
     */
    private transient NavigableMap<E,Object> m;
    // Dummy value to associate with an Object in the backing Map
    private static final Object PRESENT = new Object();
    public TreeSet() {
        this(new TreeMap<E,Object>());
    }
    public TreeSet(Comparator<? super E> comparator) {
        this(new TreeMap<>(comparator));
    }
```

add()

```java
public boolean add(E e) {
    return m.put(e, PRESENT)==null;
}
```

remove()

```java
public boolean remove(Object o) {
    return m.remove(o)==PRESENT;
}
```



## Queue

```java
public interface Queue<E> extends Collection<E> {
boolean add(E e);// 队列尾部添加
boolean offer(E e);// 队列尾部添加
E remove();// 删除并返回队列头部元素，如果头部为空，则抛异常throw new NoSuchElementException();
E poll();// 删除并返回队列头部元素，如果头部为空，则返回空
E element();// 返回队列头部元素，如果头部为空，则抛异常throw new NoSuchElementException();
E peek();// 返回队列头部元素，如果头部为空，则返回空
}
```

### ConcurrentLinkedQueue

并发单向链表结构实现的单端队列，线程安全JUC下

```java
public class ConcurrentLinkedQueue<E> extends AbstractQueue<E>
        implements Queue<E>, java.io.Serializable {
        private transient volatile Node<E> head;
        private transient volatile Node<E> tail;
        public ConcurrentLinkedQueue() {
        	head = tail = new Node<E>(null);
    	}
    	public boolean add(E e) {
            return offer(e);
        }
        public boolean offer(E e) {
            checkNotNull(e);
            final Node<E> newNode = new Node<E>(e);

            for (Node<E> t = tail, p = t;;) {
                Node<E> q = p.next;
                if (q == null) {
                    // p is last node
                    if (p.casNext(null, newNode)) {
                        // Successful CAS is the linearization point
                        // for e to become an element of this queue,
                        // and for newNode to become "live".
                        if (p != t) // hop two nodes at a time
                            casTail(t, newNode);  // Failure is OK.
                        return true;
                    }
                    // Lost CAS race to another thread; re-read next
                }
                else if (p == q)
                    // We have fallen off list.  If tail is unchanged, it
                    // will also be off-list, in which case we need to
                    // jump to head, from which all live nodes are always
                    // reachable.  Else the new tail is a better bet.
                    p = (t != (t = tail)) ? t : head;
                else
                    // Check for tail updates after two hops.
                    p = (p != t && t != (t = tail)) ? t : q;
            }
        }
        public E poll() {
            restartFromHead:
            for (;;) {
                for (Node<E> h = head, p = h, q;;) {
                    E item = p.item;

                    if (item != null && p.casItem(item, null)) {
                        // Successful CAS is the linearization point
                        // for item to be removed from this queue.
                        if (p != h) // hop two nodes at a time
                            updateHead(h, ((q = p.next) != null) ? q : p);
                        return item;
                    }
                    else if ((q = p.next) == null) {
                        updateHead(h, p);
                        return null;
                    }
                    else if (p == q)
                        continue restartFromHead;
                    else
                        p = q;
                }
            }
        }
        public E peek() {
            restartFromHead:
            for (;;) {
                for (Node<E> h = head, p = h, q;;) {
                    E item = p.item;
                    if (item != null || (q = p.next) == null) {
                        updateHead(h, p);
                        return item;
                    }
                    else if (p == q)
                        continue restartFromHead;
                    else
                        p = q;
                }
            }
        }
        Node<E> first() {
            restartFromHead:
            for (;;) {
                for (Node<E> h = head, p = h, q;;) {
                    boolean hasItem = (p.item != null);
                    if (hasItem || (q = p.next) == null) {
                        updateHead(h, p);
                        return hasItem ? p : null;
                    }
                    else if (p == q)
                        continue restartFromHead;
                    else
                        p = q;
                }
            }
        }
        public boolean remove(Object o) {
            if (o != null) {
                Node<E> next, pred = null;
                for (Node<E> p = first(); p != null; pred = p, p = next) {
                    boolean removed = false;
                    E item = p.item;
                    if (item != null) {
                        if (!o.equals(item)) {
                            next = succ(p);
                            continue;
                        }
                        removed = p.casItem(item, null);
                    }

                    next = succ(p);
                    if (pred != null && next != null) // unlink
                        pred.casNext(p, next);
                    if (removed)
                        return true;
                }
            }
            return false;
        }
```

```java
private static class Node<E> {
        volatile E item;
        volatile Node<E> next;
        Node(E item) {
            UNSAFE.putObject(this, itemOffset, item);
        }
        boolean casItem(E cmp, E val) {
            return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);
        }
        void lazySetNext(Node<E> val) {
            UNSAFE.putOrderedObject(this, nextOffset, val);
        }
        boolean casNext(Node<E> cmp, Node<E> val) {
            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);
        }
        private static final sun.misc.Unsafe UNSAFE;
        private static final long itemOffset;
        private static final long nextOffset;
        static {
            try {
                UNSAFE = sun.misc.Unsafe.getUnsafe();
                Class<?> k = Node.class;
                itemOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField("item"));
                nextOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField("next"));
            } catch (Exception e) {
                throw new Error(e);
            }
        }
    }
```





## java1.8新增的函数式编程和集合流式操作

同样java1.8新增的  接口中被default修饰符修饰的方法可以有默认实现，不强制子类必须实现或重写这些方法

```java
Collection接口
default Stream<E> stream() {// stram类，集合的流式操作
	return StreamSupport.stream(spliterator(), false);
}
default Stream<E> parallelStream() {// 并行流
	return StreamSupport.stream(spliterator(), true);
}
default boolean removeIf(Predicate<? super E> filter) {// 1.8 如果true 则删除
        Objects.requireNonNull(filter);
        boolean removed = false;
        final Iterator<E> each = iterator();
        while (each.hasNext()) {
            if (filter.test(each.next())) {
                each.remove();
                removed = true;
            }
        }
        return removed;
    }
default Spliterator<E> spliterator() {
	return Spliterators.spliterator(this, 0);
}
Iterator接口
default void forEach(Consumer<? super T> action) {
    Objects.requireNonNull(action);
    for (T t : this) {
        action.accept(t);
    }
}
default Spliterator<T> spliterator() {
        return Spliterators.spliteratorUnknownSize(iterator(), 0);
    }
```

### Stream、ParallelStream

Stream 是在 Java8 新增的特性，普遍称其为流；它不是数据结构也不存放任何数据，其主要用于集合的逻辑处理

Iterator 做为迭代器，其按照一定的顺序迭代遍历集合中的每一个元素，并且对每个元素进行指定的操作。而 Stream 在此基础上还可以将这种操作并行化，利用多核处理器的优势快速处理集合（集合的数据会分成多个段，由多个线程处理）

ParallelStream并行流执行，底层使用Fork/Join 使用ForkJoinPool的common线程池

Stream 的数据源可以有无限多个

1、流是一系列操作的集合。

2、流可以并发执行，也可以顺序执行。

既然流是一些操作的集合，那么流就可以将一个或多个操作聚集起来。这里就有两个问题：1、流是如何将这些操作聚集起来的；2、流是如何创建的的，只有知道流的创建过程，才知道流是如何连接操作的。

```java
public interface Stream<T> extends BaseStream<T, Stream<T>> {
	Stream<T> filter(Predicate<? super T> predicate);
    <R> Stream<R> map(Function<? super T, ? extends R> mapper);
    IntStream mapToInt(ToIntFunction<? super T> mapper);
    IntStream mapToInt(ToIntFunction<? super T> mapper);
    LongStream mapToLong(ToLongFunction<? super T> mapper);
    DoubleStream mapToDouble(ToDoubleFunction<? super T> mapper);
    <R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);
    IntStream flatMapToInt(Function<? super T, ? extends IntStream> mapper);
    LongStream flatMapToLong(Function<? super T, ? extends LongStream> mapper);
    DoubleStream flatMapToDouble(Function<? super T, ? extends DoubleStream> mapper);
    Stream<T> distinct();
    Stream<T> sorted();
    Stream<T> sorted(Comparator<? super T> comparator);
    Stream<T> peek(Consumer<? super T> action);
    Stream<T> limit(long maxSize);
    Stream<T> skip(long n);
    void forEach(Consumer<? super T> action);
    void forEachOrdered(Consumer<? super T> action);
    Object[] toArray();
    <A> A[] toArray(IntFunction<A[]> generator);
    T reduce(T identity, BinaryOperator<T> accumulator);
    Optional<T> reduce(BinaryOperator<T> accumulator);
    <U> U reduce(U identity,
                 BiFunction<U, ? super T, U> accumulator,
                 BinaryOperator<U> combiner);
    <R> R collect(Supplier<R> supplier,
                  BiConsumer<R, ? super T> accumulator,
                  BiConsumer<R, R> combiner);
    <R, A> R collect(Collector<? super T, A, R> collector);
    Optional<T> min(Comparator<? super T> comparator);
    Optional<T> max(Comparator<? super T> comparator);
    long count();
    boolean anyMatch(Predicate<? super T> predicate);
    boolean allMatch(Predicate<? super T> predicate);
    boolean noneMatch(Predicate<? super T> predicate);
    Optional<T> findFirst();
    Optional<T> findAny();
    
    public static<T> Builder<T> builder() {
        return new Streams.StreamBuilderImpl<>();
    }
    public static<T> Stream<T> empty() {
        return StreamSupport.stream(Spliterators.<T>emptySpliterator(), false);
    }
    public static<T> Stream<T> of(T t) {
        return StreamSupport.stream(new Streams.StreamBuilderImpl<>(t), false);
    }
    public static<T> Stream<T> of(T... values) {
        return Arrays.stream(values);
    }
    public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f) {
        Objects.requireNonNull(f);
        final Iterator<T> iterator = new Iterator<T>() {
            @SuppressWarnings("unchecked")
            T t = (T) Streams.NONE;

            @Override
            public boolean hasNext() {
                return true;
            }

            @Override
            public T next() {
                return t = (t == Streams.NONE) ? seed : f.apply(t);
            }
        };
        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(
                iterator,
                Spliterator.ORDERED | Spliterator.IMMUTABLE), false);
    }
    public static<T> Stream<T> generate(Supplier<T> s) {
        Objects.requireNonNull(s);
            return StreamSupport.stream(
                    new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef<>					 (Long.MAX_VALUE, s), false);
    }
    public static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b) {
        Objects.requireNonNull(a);
        Objects.requireNonNull(b);

        @SuppressWarnings("unchecked")
        Spliterator<T> split = new Streams.ConcatSpliterator.OfRef<>(
                (Spliterator<T>) a.spliterator(), (Spliterator<T>) b.spliterator());
        Stream<T> stream = StreamSupport.stream(split, a.isParallel() || b.isParallel());
        return stream.onClose(Streams.composedClose(a, b));
    }
}
```

Stream的**中间操作**和**终止操作**
      在上面的内容中，说到流有三个部分：开端、终端、中端。根据上面的描述，流的开端保存了数据的源，提供了一定的数据源的操作方法。而对于中端和终端，则为进行任何的描述。在JDK的文档中，将流定义为一系列操作的集合，同时JDK文档又将这些操作分为两类，即中间操作和终止操作。

返回值是Stream类型 则为中间操作

```java
		  List<Integer> lis = Arrays.asList(1,2,3,4,5,6,7,8,9);
		  Stream<Integer> stream1 = lis.stream().map(i -> i+1);  //中间操作
		  Stream<Integer> stream2 = stream1.filter(i -> i > 0);  //中间操作
		  Stream<Integer> stream3 = stream2.limit(10);  //中间操作
		  Stream<Integer> stream4 = stream3.distinct(); //中间操作
		  
		  //Optional<Integer> result1 = stream4.findAny(); //终止操作
		  //Optional<Integer> result2 = stream4.findFirst(); //终止操作，两次调用终止操作，会抛异常,流只能被使用一次，可以中间操作，也可以是终止操作
		  stream4.forEach(i -> System.out.print(i));  //终止操作，没有返回值
		  
		  //上面的所有操作有另外的一种写法
		  lis.stream().map(i -> i+1).filter(i -> i > 0)
		  	 .limit(10).distinct().forEach(i -> System.out.print(i));
			// 源集合是不会改变的
			lis.forEach(System.out::println);
```

流的所有操作不会改变源集合

| 类名            | 说明                   |
| --------------- | ---------------------- |
| RecursiveAction | 用于没有返回结果的任务 |
| RecursiveTask   | 用于有返回结果的任务   |