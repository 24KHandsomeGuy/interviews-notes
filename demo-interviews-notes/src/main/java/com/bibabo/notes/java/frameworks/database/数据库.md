# Mysql

存储引擎是插拔式的

5.5以前默认是Mysaim

5.5开始使用InnoDb

#### 索引是什么？

索引是为了加速对表中数据行的检索而创建的一种分散存储的**数据结构**

硬盘级的

#### 为什么不用平衡二叉查找树？

1.树太深了，O（logn）

2.每个节点存储太小了，比如varchar（64），一次IO操作系统一页4kb，mysql默认读16k，一个关键字64字节加上两个引用，肯定达不到16

k，浪费了一次IO

#### B-Tree多路平衡查找树

绝对平衡，子节点都在同一高度

1.树变矮了

2.一次IO读取的足够多了

为了维护树的平衡，插入时会调整树，所以索引不宜建多不冗余

##### Mysql的索引是几路平衡查找树？

取决于你建索引的关键字的大小，越小路越多，路越多树越矮

#### B+Tree

1.左闭合区间，比如找1，也要找到树的叶子节点

2.非叶子节点不保存数据，只保存关键字和引用

3.叶子节点保存数据

4.叶子节点数据区是有顺序的 天然排序

##### 优点

1.随机IO 变为顺序IO

2.非叶子节点不保存数据，磁盘读写更多，树更矮了

3.排序能力强

4.B+树查询更加稳定



#### Mysaim引擎和InnoDB引擎

##### Mysaim是每一种索引的叶子节点也就是数据区，都存储表数据对应的地址

表级锁

##### InnoDB的主键索引的叶子节点也就是数据区，直接存储数据，其余的辅助索引的叶子节点存储的都是主键索引的关键字

行级锁

InnoDB，如果没有主键，就找唯一主键作为主键，没有唯一键默认生成6位int型主键

##### CSV存储引擎  1.数据的快速导入导出   2.表格直接生成csv文件

##### Archive存储引擎  大数据量，数据压缩

##### Memory存储引擎  数据存储在内存（临时表）

#### 索引的离散性要高

#### 最左匹配原则

对索引中关键字进行计算（对比），一定是从左往右依次进行的，且不可跳过

创建数据库时可以选择  **排序规则** ASCII码

#### 普通索引



#### 主键索引

id

#### 唯一索引

#### 联合索引

1.经常用的列优先（最左匹配原则）  2.离散性高的列优先  3.宽度小的列优先

##### 覆盖索引

如果查询的列可以通过索引节点中的关键字直接返回，则该索引称之为覆盖索引

##### 实战

1.select * from wms_inv where sku_id = 2014565 and ware_id = 1;

2.select sku_id,ware_id,lot;// 

库房的wms_inv表创建一个联合索引，wms_Inv_id，sku_id，ware_id，lot

wms_Inv_id是逻辑主键，建唯一索引

sku_id + ware_id为联合索引，1,2sql都能命中

现在的InnoDB比较智能，颠倒顺序也可以命中索引



##### mysql客户端与服务端的通信方式是“半双工”

半双工指两边可以互相通信，但是某一时刻只会有一个人在讲话

全双工，两人可以同一时刻一起讲话

单工只能一方对另一方讲话

#### explain

##### type All全表扫 < index 基于索引进行全索引扫描（比如命中覆盖索引） <  range（like索引）  < ref < const唯一索引或主键索引

## 事务

一组不可分割的操作集合，数据库操作的最小操作单元

show VARIABLES like ‘autoCommit’

autoCommit 默认为ON

```java
connection.setAutocommit(false)// 关闭自动提交 要手动提交事务
......
commit()
```

### ACID

Atomic：要么一起成功、要么一起失败

Consist：数据要满足预期

Isolation：一个事务提交之前，对其他事务的是不可见的

Durability：事务做出的修改要永久保存

### 其中隔离性会因为并发事务产生以下问题

脏读：事务A修改未提交，事务B读到A事务未提交的值

不可重复读：事务A第一次读取，事务B修改，事务A二次读取时值发生了变化

**前两个是指定莫一行记录读取**  **幻读是指读取多行记录**

幻读：事务A第一次范围读取，只读到两条记录，事务B插入一条未提交，事务A第二次读取读到了三条记录

### 事务隔离级别标准

未提交读：什么问题都没解决

已提交读：解决脏读

可重复读：解决不可重读

串行化：解决幻读

InnoDB默认是可重复读级别，但是解决了幻读的问题

## InnoDB是如何实现事务隔离级别标准的？锁和MVCC

### 锁

innoDB的行锁是通过对索引上的索引项加锁实现的

只有通过索引条件进行数据检索，才会使用行级锁，否则使用表锁（InnoDB的表锁是通过锁住所有行实现的）

假如id是主键索引，name是二级索引辅助索引，如果update的where条件是name过滤的话，那么会先在二级索引上加锁，然后再到找到二级索引的数据区也就是找到主键索引 在主键索引上加锁。会加两把锁

##### 1.共享锁（行锁）

lock in Share mode

一个事务获取到共享锁，其他事务也可以获取到这个共享锁，但不可以获取排他锁

##### 2.排他锁（行锁）

for update

一个是事务获取到排他锁 其他事务不能获取排他锁或共享锁

##### 3.意向共享锁（表锁）

在获取共享锁之前，必须先获得意向共享锁，一把意向共享锁可以被多个事务共持有

##### 4.意向排他锁（表锁）

在获取排他锁之前，必须先获得意向排他锁，一把意向排他锁可以被多个事务共持有

意向锁的作用？当有事务想锁表时，需要判断意向锁是否存在，必须等意向锁释放才能锁表

##### 5.自增锁

对于自增列自增长的一个特殊的表级别锁

show variables like 'innodb_autoinc_lock_mode';

默认自增值为1，事务未提交ID永久丢失

##### 行锁的算法

 1 4 6 7 10 

会分为6个区间 (-~ , 1]、(1 , 4]、( 4, 6 ]、( 6, 7 ]、( 7, 10 ]、(10 , +~]

##### 记录锁 record lock

唯一索引或者主键索引，查询条件是精准匹配，退化为Record锁

select * from user where id =4 for update

**ps：如果是可重复的普通索引，锁的是（1 ， 6）1-6开区间锁住**

##### 间隙锁 gap lock

命中索引后，记录不存在，那么临建锁会退化为Gap锁，也就是只锁一个区间

select * from user where id = 5 for update

( 4, 6 )锁住这个区间 左开右开

**只在RR隔离界别存在**

##### 临键锁（默认行锁算法）next-key lock = gap lock + record lock

select * from user where id > 5 and id < 9 for update;

命中索引后，记录存在6 7  锁住的是记录的当前区间和下一个区间( 4, 6 ]、( 6, 7 ]、( 7, 10 ]，如果现在另一个事务插入8是插不进去的，那么当前事务再次读取的时候，就不会出现幻读



##### 1.如何用锁解决脏读？

读加共享锁，改加排他锁

##### 2.如何用锁解决不可重复读？

读加共享锁，改加排他锁

##### 3.如何用锁解决幻读？

读加排他锁，默认是临建锁，nextkey锁  锁住当前记录所在区间和下一个区间，这样就可以解决幻读

#### 死锁

死锁的避免

1.固定顺序的访问表和行

2.大事务拆小

3.如果业务允许，降低事务隔离级别  因为间隙锁和临建锁 只存在RR隔离级别，所以降低隔离级别后，就不会锁住区间了，锁的粒度就变小了

4.建立合理的索引 尽量避免表锁

默认事务隔离级别就是RR 可重复读

##### 当前读使用临建锁解决幻读、快照读使用MVCC解决幻读

### MVCC(多版本并发控制)

Mutiversion Concurrency Control

对事务内处理的数据做多版本的管理，以达到用来避免写操作的阻塞，从而引发读操作的并发问题

数据行版本号和删除版本号

开起一个事务会分配全局事务id

插入时，数据行版本号为事务id

删除时，删除版本号为事务id

修改时，先把修改的行copy新行，先插入数据行版本号为事务id，再把原行的删除版本号为事务id

查询时，1.找数据行版本号早于当前事务版本号 2.找删除版本号为null或者删除版本号大于当前版本号（小于当前版本号的说明已经删除不要了）



# 幂等

在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同

## 保证幂等性的方案

### Redis

1.不存在并发的场景。比如消息的消费

```java
// 发送端代码
// 生成一个唯一ID，例如时间戳，或UUID或token
String uid = UUID...;
Message message = new Message(消息体中附带uid);

// 消费端代码
// 检查消息是否消费过
String val = redisTemplate.get(KEY_PREFIX + UID);
if (val != null) {return "success"};
// 执行本地事务
begin transaction;
// 执行成功后将消息中的uid写入到redis中
redisTemplate.set(KEY_PREFIX + UID);
```

2.存在并发的场景。这种一般是异常情况，同一时刻客户端发送了多次相同的请求。需要加层分布式锁

```java
// 客户端代码
// 生成一个唯一ID，例如时间戳，或UUID
String uid = UUID...;
Message message = new Message(消息体中附带uid);

// 服务端代码
redisTemplate.lock();
// 检查消息是否消费过
String val = redisTemplate.get(KEY_PREFIX + UID);
if (val != null) {return "success"};
// 执行本地事务
begin transaction;
// 执行成功后将消息中的uid写入到redis中
redisTemplate.set(KEY_PREFIX + UID);
redisTemplate.unlock();
```

### 数据库

1.数据库的唯一约束。UNQUE_KEY  insert 抛出DuplicateKeyException。

比如业务上天然的唯一键如orderId skuId

非天然的。服务端创建一个消息表，基于消息生成MD5作为唯一键做插入，插入成功则处理，异常则认为被幂等校验了

