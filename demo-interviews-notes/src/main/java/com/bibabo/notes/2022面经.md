# OK

## JVM

1.垃圾回收器	全过一遍，答得一般

2.**垃圾回收算法**  答得一般

3.**类加载机制**  没答上来，被封存在记忆深处了

4.**一个空对象占多少内存**  压根就不清楚

## SpirngBoot

1.第一个注解是什么？ @SpringBootApplication

2.自动装配注解是什么？ @EnableAutoConfiguration -> @Import({AutoConfigurationImportSelector.class})

3.spring.factories是所有类都加载么？ 不会，SpringBoot使用SPI只会加载文件中key为org.springframework.boot.autoconfigure.EnableAutoConfiguration的配置类

其实他想问的是Condition条件装配。没明白他问啥，表述有问题

## Redis

1.几种数据类型？ 5种。他说有7种，一种bitmap，一种啥忘记了。这个还需要再确认下

## HashMap

1.jdk1.8 底层数据结构 数组+链表/红黑树 

2.查询插入的时间复杂度是多少  O(1)  他说不对，我后来分析了下，这个问题应该分场景

​				1.理想情况下不存在hash碰撞 O(1)

​				2.存在hash碰撞 单向链表O(1) + O(n) = O(n)

​				3.链表长度大于6 转红黑树O(1) + O(logn) = O(logn)

## Mysql

1.事务隔离级别

 未提交读 脏读、不可重复读、幻读都没解决

 已提交读 脏读解决了，不可重复读、幻读没解决

 可重复读  幻读没解决

 串行化  全部解决

2.spring中的事务传播有哪几种？没答上来嘎嘎

### Spring中七种事务传播行为

| 序号 | 事务传播行为类型          | 说明                                                         |
| ---- | ------------------------- | ------------------------------------------------------------ |
| 1    | PROPAGATION_REQUIRED      | 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。默认 |
| 2    | PROPAGATION_SUPPORTS      | 支持当前事务，如果当前没有事务，就以非事务方式执行           |
| 3    | PROPAGATION_MANDATORY     | 使用当前的事务，如果当前没有事务，就抛出异常。               |
| 4    | PROPAGATION_REQUIRES_NEW  | 新建事务，如果当前存在事务，把当前事务挂起。                 |
| 5    | PROPAGATION_NOT_SUPPORTED | 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。   |
| 6    | PROPAGATION_NEVER         | 以非事务方式执行，如果当前存在事务，则抛出异常。             |
| 7    | PROPAGATION_NESTED        | 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 |

1、2、3为一组，都表现对当前事务的支持，不同的在于当前不存在事务的处理方式；4、5、6为一组，都表现对当前事务的不支持，不同的在于当前有事务的处理方式。然后7单独一组。

其中PROPAGATION_NESTED想做到A回滚B一起回滚、B回滚A正常提交的场景

结合了1、4

## 动态代理用在哪些场景

Spring事务、Mybatis、Dubbo客户端引用

## 分布式

1.BASE理论

BASE 理论是对 CAP 中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。

2.2pc缺点



3.3pc





## 设计模式

1.讲下23种设计模式   此时我的内心一万草泥马在崩腾

最后每种模式讲了几个

1.创建型

2.结构型

3.行为型