# OK

## JVM

1.垃圾回收器	全过一遍，答得一般

2.**垃圾回收算法**  答得一般

3.**类加载机制**  没答上来，被封存在记忆深处了

4.**一个空对象占多少内存**  压根就不清楚

## SpirngBoot

1.第一个注解是什么？ @SpringBootApplication

2.自动装配注解是什么？ @EnableAutoConfiguration -> @Import({AutoConfigurationImportSelector.class})

3.spring.factories是所有类都加载么？ 不会，SpringBoot使用SPI只会加载文件中key为org.springframework.boot.autoconfigure.EnableAutoConfiguration的配置类

其实他想问的是Condition条件装配。没明白他问啥，表述有问题

## Redis

1.几种数据类型？ 5种。他说有7种，一种bitmap，一种啥忘记了。这个还需要再确认下

## HashMap

1.jdk1.8 底层数据结构 数组+链表/红黑树 

2.查询插入的时间复杂度是多少  O(1)  他说不对，我后来分析了下，这个问题应该分场景

​				1.理想情况下不存在hash碰撞 O(1)

​				2.存在hash碰撞 单向链表O(1) + O(n) = O(n)

​				3.链表长度大于6 转红黑树O(1) + O(logn) = O(logn)

## Mysql

1.事务隔离级别

 未提交读 脏读、不可重复读、幻读都没解决

 已提交读 脏读解决了，不可重复读、幻读没解决

 可重复读  幻读没解决

 串行化  全部解决

2.spring中的事务传播有哪几种？没答上来嘎嘎

### Spring中七种事务传播行为

| 序号 | 事务传播行为类型          | 说明                                                         |
| ---- | ------------------------- | ------------------------------------------------------------ |
| 1    | PROPAGATION_REQUIRED      | 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。默认 |
| 2    | PROPAGATION_SUPPORTS      | 支持当前事务，如果当前没有事务，就以非事务方式执行           |
| 3    | PROPAGATION_MANDATORY     | 使用当前的事务，如果当前没有事务，就抛出异常。               |
| 4    | PROPAGATION_REQUIRES_NEW  | 新建事务，如果当前存在事务，把当前事务挂起。                 |
| 5    | PROPAGATION_NOT_SUPPORTED | 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。   |
| 6    | PROPAGATION_NEVER         | 以非事务方式执行，如果当前存在事务，则抛出异常。             |
| 7    | PROPAGATION_NESTED        | 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 |

1、2、3为一组，都表现对当前事务的支持，不同的在于当前不存在事务的处理方式；4、5、6为一组，都表现对当前事务的不支持，不同的在于当前有事务的处理方式。然后7单独一组。

其中PROPAGATION_NESTED想做到A回滚B一起回滚、B回滚A正常提交的场景

结合了1、4

## 动态代理用在哪些场景

Spring事务、Mybatis、Dubbo客户端引用

## 分布式

1.BASE理论

BASE 理论是对 CAP 中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。

2.2pc缺点



3.3pc





## 设计模式

1.讲下23种设计模式   此时我的内心一万草泥马在崩腾

最后每种模式讲了几个

1.创建型

2.结构型

3.行为型


## 线程池

1.线程池的参数

2.拒绝策略
Abort丢弃并抛异常
Discard丢弃不抛异常
DiscardOldest丢弃掉最早的，重新提交当前
CallerRun当前线程执行

3.ThreadLocal
存储值使用的是哪种？强引用、弱引用、软引用、虚引用
假设threadLocal使用的是强引用，在业务代码中执行 threadLocalInstance=null 操作，
以实现清理掉 threadLocal 实例的目的，但是因为 threadLocalMap 的 Entry 强引用 threadLocal，
因此在 gc 的时候进行可达性分析，threadLocal 依然可达，对 threadLocal 并不会进行垃圾回收，这样就无法真正达到业务逻辑的目的


# 网易有道一面
## 订单超时支付优化
1.订单创建后10分钟会支付超时，你们是怎样做得
答：job每2s检查一次，创建时间+10分钟>当前时间得订单，自动取消掉
2.job每隔一秒抓取一次会有延迟，而且单量很多得情况下会处理不及时，怎么优化？
答：使用rocketmq得消息延时发送，创建订单时，发送一个10分钟得延时消息，
消费者消费这个消息时，检查下是否已经支付，如果已经支付，不做处理，如果未支付，该消息处理订单为取消掉

## 数据库设计
1.公司有很多个员工，每个员工都有对应得上级和下级，，设计表，查询员工所有下属变得高效
答：一张员工表，存在上级领导字段和下级领导字段，递归去查找
2.有没有更好的设计
有思路，但是现场没答上来
员工表
员工id 	NAME 		职位id
1	张三		1
2	李四		2
3	王五		3
4	赵六		4
5	刘七		5

职位表
职位id     职位的名称
1	CEO
2	CTO
3	技术总监
4	开发组长
5	java开发

SELECT * FROM 员工表
WHERE 员工id IN (
	SELECT 职位id FROM 职位表 
	WHERE 职位id > (SELECT 职位id FROM 员工表 WHERE id = 2)
)

## 算法
int[] arr = new int[]{-1,2,-1}
求出最大和范围的值，比如此种情况为2
一道很简单的算法我居然没写上来OMG

## SOA架构的优缺点
1.优点
面向服务架构，清晰的功能模块领域划分
2.缺点
服务的粒度相比于微服务还不够细，比如接单服务会和其他服务接口放到一起，重启会影响到，微服务的话就不会


# 字节跳动飞书一面
## 算法题
1.


## mysql
1.隔离级别、分别解决了哪些问题
未提交读  脏读未解决
已提交读  不可重复读未解决
可重复读  幻读未解决
串行化    幻读解决

2.innodb默认隔离级别
可重复读，但是解决了幻读，通过锁或者mvcc

3.mvcc
多版本并发控制，只能读取数据行版本号小于等于当前事务版本号，大于删除版本号或为null得数据

## redis和数据库的数据一致性如何保证
答：分布式读写锁保证
效率会低，容忍数据一致延迟，怎么做？
没答上来

## rocketmq
1.如何保证rocketmq的消息发送一定是成功的？
答：事务型消息，存在事务回查机制，保证本地事务和mq的一致性
2.如何保证幂等？
答：可以借助数据库做幂等、也可以借助redis做幂等

###chatGpt
RocketMQ 提供了多种保证消息发送成功的方法，以下是一些常见的方法：

1.可靠的消息传递：RocketMQ 保证消息的可靠性传递，并且提供了重试机制，确保消息最终一定会被消费者接收到。

2.消息发送确认：RocketMQ 支持发送端确认，这样可以确保消息已经被正确写入到消息队列中，并且未被丢失。

3.幂等性：RocketMQ 支持消息的幂等性，可以保证消息的不重复消费。

4.双写：RocketMQ 支持双写机制，可以确保消息在发送到消息队列之前已经被完整写入到本地存储。

5.数据一致性：RocketMQ 支持数据一致性，确保消息的顺序性和一致性。

通过以上这些方法，RocketMQ 可以保证消息发送的可靠性。不过，为了保证消息发送的一定成功，您需要合理地配置 RocketMQ 参数以及在系统的网络环境等方面做好相关的准备工作。

## 设计一个答题网站
我不知道他要问啥，题库啥的


## jvm类加载机制
没答上来，这个已经被问两次了，需要重点复习下



# 字节飞书一面
## 如何保证mysql和redis的数据一致性？
