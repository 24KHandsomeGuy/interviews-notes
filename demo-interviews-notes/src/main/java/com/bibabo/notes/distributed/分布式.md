# 分布式数据一致性

## CAP理论

CAP理论，指的是在一个分布式系统中，Consistency(一致性)、Availability(可用性)、Partition Tolerance(分区容错性)，不能同时成立。

*Consistency* : Every read receives the most recent write or an error
*Availability* : Every request receives a (non-error) response – without the guarantee that it contains the most recent write
*Partition tolerance* : The system continues to operate despite an arbitrary number of messages being dropped (or delayed) by the network between nodes

①**一致性：**对于客户端的每次读操作，要么读到的是最新的数据，要么读取失败。换句话说，一致性是站在分布式系统的角度，对访问本系统的客户端的一种承诺：要么我给您返回一个错误，要么我给你返回绝对一致的最新数据，不难看出，其强调的是数据正确。

**数据一定是最新的，那么多个数据存储节点的数据就一定是一致的**

②**可用性：**任何客户端的请求都能得到响应数据，不会出现响应错误。换句话说，可用性是站在分布式系统的角度，对访问本系统的客户的另一种承诺：我一定会给您返回数据，不会给你返回错误，但不保证数据最新，强调的是不出错。

**在一定时间范围内，一定会返回一个数据结果，但不保证返回的是最新的**

③**分区容忍性：**由于分布式系统通过网络进行通信，网络是不可靠的。当任意数量的消息丢失或延迟到达时，系统仍会继续提供服务，不会挂掉。换句话说，分区容忍性是站在分布式系统的角度，对访问本系统的客户端的再一种承诺：我会一直运行，不管我的内部出现何种数据同步问题，强调的是不挂掉。



在不存在网络失败的情况下（分布式系统正常运行时），C和A能够同时保证。只有当网络发生分区或失败时，才会在C和A之间做出选择。

**由于P一定会发生，所以C、A不能够同时保证**

对于一个分布式系统而言，P是前提，必须保证，因为只要有网络交互就一定会有延迟和数据丢失，这种状况我们必须接受，必须保证系统不能挂掉。所以只剩下C、A可以选择。要么保证数据一致性（保证数据绝对正确），要么保证可用性（保证系统不出错）。

当选择了C（一致性）时，如果由于网络分区而无法保证特定信息是最新的，则系统将返回错误或超时。

当选择了A（可用性）时，系统将始终处理客户端的查询并尝试返回最新的可用的信息版本，即使由于网络分区而无法保证其是最新的。



## BASE理论

BASE 理论是对 CAP 中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。

BASE理论是Basically Available(基本可用)，Soft State（软状态）和Eventually Consistent（最终一致性）三个短语的缩写。

弱一致性、最终一致性



BASE理论的内容

基本可用（Basically Available）软状态（Soft State）最终一致性（Eventually Consistent）下面展开讨论：

### 1.基本可用

什么是基本可用呢？假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言：

**响应时间上的损失**：正常情况下的搜索引擎0.5秒即返回给用户结果，而基本可用的搜索引擎可以在2秒作用返回结果。**功能上的损失**：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单。但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。

### 2.软状态

什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。

软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。

### 3.最终一致性

上面说软状态，然后不可能一直是软状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限取决于网络延时、系统负载、数据复制方案设计等等因素。

而在实际工程实践中，最终一致性分为5种：

#### 3.1. 因果一致性（Causal consistency）

因果一致性指的是：如果节点A在更新完某个数据后通知了节点B，那么节点B之后对该数据的访问和修改都是基于A更新后的值。于此同时，和节点A无因果关系的节点C的数据访问则没有这样的限制。

#### 3.2. 读己之所写（Read your writes）

读己之所写指的是：节点A更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性。

#### 3.3. 会话一致性（Session consistency）

会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。

#### 3.4. 单调读一致性（Monotonic read consistency）

单调读一致性指的是：如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。

#### 3.5. 单调写一致性（Monotonic write consistency）

单调写一致性指的是：一个系统要能够保证来自同一个节点的写操作被顺序的执行。



在实际的实践中，这5种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。

实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的。比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例。

小结

总体来说BASE理论面向的是大型高可用、可扩展的分布式系统。与传统ACID特性相反，不同于ACID的强一致性模型，BASE提出通过牺牲强一致性来获得可用性，并允许数据段时间内的不一致，但是最终达到一致状态。同时，在实际分布式场景中，不同业务对数据的一致性要求不一样。因此在设计中，ACID和BASE理论往往又会结合使用。

### 实际应用中的最终一致性方案

#### 1.提供查询服务，确认数据的状态



#### 2.借助本地事务原子性，插入异步通知表，定时任务抓取同步



#### 3.TCC事务补偿

- 简介

- - 2007年，Pat Helland发表了一篇名为《Life beyond Distributed Transactions: an Apostate’s Opinion》的论文，提出了TCC（Try-Confirm-Cancel） 的概念。

  - 两阶段提交（2PC）和三阶段提交（3PC）并不适用于并发量大的业务场景。TCC事务机制相比于2PC、3PC，不会锁定整个资源，而是通过引入补偿机制，将资源转换为业务逻辑形式，锁的粒度变小。

  - TCC的核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作，分为三个阶段：

  - - Try：这个阶段对各个服务的资源做检测以及对资源进行锁定或者预留；
    - Confirm ：执行真正的业务操作，不作任何业务检查，只使用Try阶段预留的业务资源，Confirm操作要求具备幂等设计，Confirm失败后需要进行重试；
    - Cancel：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，即执行回滚操作，释放Try阶段预留的业务资源 ，Cancel操作要求具备幂等设计，Cancel失败后需要进行重试

例如：电商系统中有两个服务：订单服务A、库存服务B：对外提供服务时，必须接受一些不确定性，即对服务A/B的一次调用仅是一个临时性操作，服务消费方保留了后续的取消权。如果消费方认为全局事务应该rollback，它会要求取消之前的临时性操作；如果消费方认为全局事务应该commit时，它会进行的一个确认操作。



- Try

- - Try阶段一般用于锁定某个资源，设置一个预备状态或冻结部分数据。对于示例中的每一个服务，Try阶段所做的工作如下：

  - - 订单服务：先置一个中间状态“UPDATING”，而不是直接设置“支付成功”状态；
    - 库存服务：先用一个冻结库存字段保存冻结库存数，而不是直接扣掉库存；
    - 积分服务：预增加会员积分；
    - 仓储服务：创建销售出库单，但状态是UNKONWN。

- Confirm

- - 根据Try阶段的执行情况，Confirm分为两种情况：

  - - 理想情况下，所有Try全部执行成功，则执行各个服务的Confirm逻辑；
    - 部分服务Try执行失败，则执行第三阶段——Cancel。

  - Confirm阶段一般需要各个服务自己实现Confirm逻辑：

  - - 订单服务：confirm逻辑可以是将订单的中间状态变更为PAYED-支付成功；
    - 库存服务：将冻结库存数清零，同时扣减掉真正的库存；
    - 积分服务：将预增加积分清零，同时增加真实会员积分；
    - 仓储服务：修改销售出库单的状态为已创建-CREATED。

- Confirm阶段的各个服务本身可能出现问题，这时候一般就需要TCC框架了（比如ByteTCC，tcc-transaction，himly），TCC事务框架一般会记录一些分布式事务的活动日志，保存事务运行的各个阶段和状态，从而保证整个分布式事务的最终一致性。

- Cancel

- - 如果Try阶段执行异常，就会执行Cancel阶段。比如：对于订单服务，可以实现的一种Cancel逻辑就是：将订单的状态设置为“CANCELED”；对于库存服务，Cancel逻辑就是：将冻结库存扣减掉，加回到可销售库存里去。

- - - 许多公司为了简化TCC的使用，通常会将一个服务的某个核心接口拆成两个，比如库存服务的扣减库存接口，拆成两个子接口：①扣减接口 ②回滚扣减库存接口，由TCC框架来保证当某个接口执行失败后去执行对应的rollback接口。

- 总结

- - 从正常的流程上讲，TCC仍然是一个两阶段提交协议。但是，在执行出现问题的时候，有一定的自我修复能力，如果任何一个事务参与者出现了问题，协调者可以通过执行逆操作来取消之前的操作，达到最终的一致状态（比如冲正交易、查询交易）。

  - 从TCC的执行流程也可以看出，服务提供方需要提供额外的补偿逻辑，那么原来一个服务接口，引入TCC后可能要改造成3种逻辑：

  - - Try：先是服务调用链路依次执行Try逻辑；
    - Confirm：如果都正常的话，TCC分布式事务框架推进执行Confirm逻辑，完成整个事务；
    - Cancel：如果某个服务的Try逻辑有问题，TCC分布式事务框架感知到之后就会推进执行各个服务的Cancel逻辑，撤销之前执行的各种操作。

  - 注意：在设计TCC事务时，接口的Cancel和Confirm操作都必须满足幂等设计。

  - 框架选型

  - - TCC框架的可供选择余地比较少，目前相对比较成熟的是阿里开源的分布式事务框架seata（[https://github.com/seata/seata](https://link.zhihu.com/?target=https%3A//github.com/seata/seata)），这个框架是经历过阿里生产环境的大量考验，同时也支持dubbo、spring cloud。

  - 优点

  - - 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些，当然性能也可以得到提升。

  - 缺点

  - - TCC模型对业务的侵入性太强，事务回滚实际上就是自己写业务代码来进行回滚和补偿，改造的难度大。一般来说支付、交易等核心业务场景，可能会用TCC来严格保证分布式事务的一致性，要么全部成功，要么全部自动回滚。这些业务场景都是整个公司的核心业务有，比如银行核心主机的账务系统，不容半点差池。
    - 但是，在一般的业务场景下，尽量别没事就用TCC作为分布式事务的解决方案，因为自己手写回滚/补偿逻辑，会造成业务代码臃肿且很难维护。

#### 4.可靠性消息的最终一致性

如rocketmq的半消息 + 事务回查

#### 5.定期校对





# 分布式事务

保证关系型数据库分布式数据一致性

## XA

XA协议由Tuxedo首先提出的，并交给X/Open组织，作为[资源管理器](https://baike.baidu.com/item/资源管理器/1951545)（数据库）与[事务](https://baike.baidu.com/item/事务)管理器的接口标准。[Oracle](https://baike.baidu.com/item/Oracle/301207)、[Informix](https://baike.baidu.com/item/Informix/269954)、[DB2](https://baike.baidu.com/item/DB2/7034285)和[Sybase](https://baike.baidu.com/item/Sybase/2138155)等各大数据库厂家都提供对XA的支持。XA协议采用两阶段提交方式来管理[分布式事务](https://baike.baidu.com/item/分布式事务/4747029)。XA接口提供资源管理器与事务管理器之间进行通信的标准接口。XA协议包括两套函数，以xa_开头的及以ax_开头的。

二阶提交

#### AP

应用程序。比如我们的JAVA应用

#### TM

事务协调者。比如我们的SEATA框架

#### RM

资源管理者。比如Mysql、Oracle



### Mysql

mysql支持XA协议文档https://dev.mysql.com/doc/refman/8.0/en/xa.html

#### 13.3.8.1 XA Transaction SQL Statements

To perform XA transactions in MySQL, use the following statements:

```sql
#第一阶段
#开启一个xid的事务
XA {START|BEGIN} xid [JOIN|RESUME]
#执行sql语句
#结束一个xid的事务
XA END xid [SUSPEND [FOR MIGRATE]]
#向TM表明已经准备好了
XA PREPARE xid

#第二阶段
#提交事务
XA COMMIT xid [ONE PHASE]
#回滚事务
XA ROLLBACK xid

XA RECOVER [CONVERT XID]
```



例子如下，两个不同机器上的mysql数据库为例

oms_db

```sql
XA START 'TEST01';
INSERT INTO `oms_db`.`oms_order_main` ...
XA END 'TEST01';
XA PREPARE 'TEST01';

##由TM来决定，事务是该提交还是回滚
XA ROLLBACK 'TEST01';
```

order_main

```sql
XA START 'TEST02';
INSERT INTO order_main ...
XA END 'TEST02';
XA PREPARE 'TEST02';

##由TM来决定，事务是该提交还是回滚
XA ROLLBACK 'TEST02';
```

**TM先开启为每一个RM开启事务，RM执行结束后，根据每个RM的执行结果，来决定全局的、也就是第二阶段的提交或回滚**

那么，如果在第二阶段，一个RM执行COMMIT成功了，但是另一个RM执行COMMIT失败了，数据结果和我们预期的还是不一致，那该怎么办呢？？？这是TM需要解决的问题，比如SEATA，后续探究一下



### JTA

JTA，即Java Transaction API，JTA允许应用程序执行分布式事务处理——在两个或多个网络计算机资源上访问并且更新数据。[JDBC](https://baike.baidu.com/item/JDBC)[驱动程序](https://baike.baidu.com/item/驱动程序)的JTA支持极大地增强了数据访问能力。

Java提供了基于XA的应用程序执行分布式事务处理

如rt.jar->javax.sql.XAConnection、XADataSource   javax.transaction.xa.Xid

不同的数据库厂商的实现，比如mysql

```
com.mysql.cj.jdbc.MysqlXAConnection
```



Java虽然提供了相应的实现规范接口，但是如果我们自己实现还是需要考虑比如第二阶段的完全成功，所以引出已经成熟的分布式事务框架如Atomikos、Bitronix、Seata



## Seata

### AT模式



### TCC模式



### SAGA模式



### XA模式









# 幂等

在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同

## 保证幂等性的方案

### Redis

1.不存在并发的场景。比如消息的消费

```java
// 发送端代码
// 生成一个唯一ID，例如时间戳，或UUID或token
String uid = UUID...;
Message message = new Message(消息体中附带uid);

// 消费端代码
// 检查消息是否消费过
String val = redisTemplate.get(KEY_PREFIX + UID);
if (val != null) {return "success"};
// 执行本地事务
begin transaction;
// 执行成功后将消息中的uid写入到redis中
redisTemplate.set(KEY_PREFIX + UID);
```

2.存在并发的场景。这种一般是异常情况，同一时刻客户端发送了多次相同的请求。需要加层分布式锁

```java
// 客户端代码
// 生成一个唯一ID，例如时间戳，或UUID
String uid = UUID...;
Message message = new Message(消息体中附带uid);

// 服务端代码
redisTemplate.lock();
// 检查消息是否消费过
String val = redisTemplate.get(KEY_PREFIX + UID);
if (val != null) {return "success"};
// 执行本地事务
begin transaction;
// 执行成功后将消息中的uid写入到redis中
redisTemplate.set(KEY_PREFIX + UID);
redisTemplate.unlock();
```

### 数据库

1.数据库的唯一约束。UNQUE_KEY  insert 抛出DuplicateKeyException。

比如业务上天然的唯一键如orderId skuId

非天然的。服务端创建一个消息表，基于消息生成MD5作为唯一键做插入，插入成功则处理，异常则认为被幂等校验了

