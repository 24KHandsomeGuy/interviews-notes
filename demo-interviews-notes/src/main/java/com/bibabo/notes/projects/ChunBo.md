# OMS

## 正向

### 订单的创建

ToC：C端主站App、Web、小程序、礼享集兑换（用户在第三方平台跳转到春播收银台兑换商品）

ToB：销售计划（企业销售）、第三方平台订单（抖音、有赞...）、补发单、换发单

**拉回生成新订单**：只有这个操作不需要调用**接单接口**

### 接单接口

#### 1.几台服务？

#### 2.TPS、QPS峰值是多少？

#### 3.网站PV是多少？

#### 4.每日单量是多少？

#### 5.如何保证下单时多系统数据强一致

PV和单量差不多30:1，按照这个比例去推测数据

1. 6台服务

2. Pinpoint监控，TPS + QPS也就是服务总请求量监控

   访问高峰9-11点（极速达）、19-21点（次日达），总请求量300，单机50。

   **如何提升的QPS**？读写分离数据库、redis、ElasticSearch

3. PV：春节前夕450W，日常300W

4. 春节前每日15W单，日常10W单

5. 目前下单时会去扣减库存，订单系统开启本地事务生单，本地事务结束前调用库存系统扣减库存，如果扣减成功则生单成功，如果扣减库存失败则抛异常回滚事务。

   **问题**：库存系统虽然扣减成功了，但是事务在结束的前一刻，系统DOWN机或者机房停电，那么会导致库存系统可卖数变少，会少卖一些商品。

   **但目前还没出现过这类问题，概率很小。**

   **优化**：可以使用Seata的AT模式

### 支付成功通知订单系统

#### 哪种订单需要支付？

ToB的订单是不需要支付的。

像企销、第三方订单等都是先售卖，再按月或者季度、或者年去结算

像补发、换发、拉回单也是不需要支付的

**C端主站App、Web、小程序有可能需要支付现金**

为什么是有可能。

用户提交订单，如果存在非现金扣减，前端先调用支付系统非现金部分扣减。扣减成功后，前端调用订单系统创建订单成功，如果还需要支付现金部分，再调用支付系统现金收银台，根据具体支付渠道跳转后进行现金支付。

#### 订单支付超时取消，但用户却支付成功

1.用户下单后，即使超时了，也未曾发起过支付

**之前的做法**：订单系统job每5s抓取支付超时订单申请取消

**现在的做法**：订单创建时RocketMq插入一条10min的延时消息，消息的消费者检测如果订单尚未支付则取消这个订单

2.用户下单后，超时临界点发起支付

比如10min时发起支付，支付系统询问订单系统是否可以支付

**之前的做法**：订单系统接口判断订单是否已经提交取消申请，如果没有取消申请，但有可能支付超时的流程正在处理中还尚未结束，这样接口也会返回可以支付，造成问题

**现在的做法**：订单系统接口判断订单是否已经提交取消申请，如果没有取消申请，那仍需要实时判断下订单时间是否超时

3.用户下单后，发起支付跳转到第三方支付平台，但在第三方平台收银台界面停留时间超过我们系统的支付超时时间限制

**之前的做法**：无

**现在的做法**：这种情况我们是无法控制对方的系统的，只有在支付申请的时候把我们禁止提交支付的时间戳带给第三方支付平台

#### 支付成功后订单执行异步履约流程

用户在支付平台支付成功后，通知支付系统paycenter，支付系统通知订单系统

**之前的做法**：订单履约流程使用job + 多线程的模式执行。订单履约17个节点（一个初始job，16个补漏job），job30s抓取一次，将任务抓取到后，扔入线程池中执行。

订单履约的初始节点job，会检测订单是否已支付，如果没有支付则不做处理，直到订单支付成功或者取消。

如果订单支付成功，开启履约流程，使用状态模式不断地向下处理

**现在的做法**：1.在订单系统中接收支付成功的接口，加一个动作，RocketMq发送一条事务**消息**，支付成功标识写入DB的同时消息也落Q。

这条消息的消费者，是整个订单履约流程起点。

这样做的好处是，尽可能地保证了支付成功后尽快开启履约流程的时效性（job的30s省了）、在未支付时不需要job浪费CPU资源不断检查、削锋流量，消息在Mq中，系统会陆续消费。

2.使用生产者+消费者模型（阻塞队列）最大化系统吞吐

在之前的做法中，已经使用了多线程，那这里利用生产者消费者的模式 + 多线程会有什么不同呢？

线程分为I/O密集型和CPU密集型，I/O可能是系统交互需要网络通信，CPU则是纯内存计算，不需要很多的耗时网络交互、db交互。

那如果是之前的做法，线程的数量不好设置，没办法最大化吞吐。如8核CPU，前5个节点是CPU密集型，但是再5个节点是I/O密集型。

如果线程池的大小设置为8则前5个节点不需要切换时间片但再5个节点会阻塞等待网络I/O，这样CPU资源就浪费了。但如果把线程池数量设置为64，前5个节点又会频繁切换时间片。

17个节点都存在自己的worker，只take()自己的阻塞队列，take到任务后，扔到*线程池*中执行，任务执行完毕再根据策略模式决定下一个状态是什么，生产offer()到指定的阻塞队列中。此时worker中的线程池就可以根据自己的线程类型是I/O密集还是CPU密集和处理逻辑的复杂度自定义线程池数量。比如少量的I/O密集就给到16个线程数，大量的I/O密集就给到64个线程数，CPU密集就给8个线程等等。

#### 订单履约的17步骤

初始环节（订单发送短信、推送公众号、小程序订单推送支付成功）

异常检查（金额的检验、地址的校验）

订单附赠（填充赠品）

订单填充（虚拟组套的填充、商品中心获取销项税等信息填充）

订单分摊（订单头上的各款项金额分摊到商品行上）

凭证推送（推送财务系统支付凭证）

订单拆分（交易单会把相同规则的商品明细行拆分成一个订单。规则如：仓库、收货时间、供应商...）

自动审核（获取同盾得分检查订单是否为作弊订单，作弊需要取消）

预售订单推采销平台（预售订单的把商品推送给预售系统）

生效时间（通过履约时间计算出生效时间，未到达生效时间需要暂停）

获取运单号（向TMS申请分配快递）

分配ERP库存（占用ERP库存）

订单下发库房流量限制（按照库房配置的仓配能力来控制每日下发WMS的订单数量，如果仓配能力已满，需要暂停）

换发补发单发短信（发短信通知客户）

生成发票（数据推送发票系统）

下发WMS（两种情况：1.WMS也就是我们自己的ERP系统 2.产地直发供应商直接发货给用户）

## Gift附赠

### 附赠的两种类型

1.商品劵（直接到账户）  2.商品（随单赠送，履约流程中填充）

### 附赠的领取动作

1.业务人员发放（ToB）  2.弹窗领劵（ToC） 

#### 业务人员发放

Web系统：市场部、增长部的同事新建活动，建立活动规则，提交。

活动主表、活动条件表、需要排除的用户表、活动附赠商品或劵的信息表落库。

**如果附赠是商品**结束不发送Mq，候选人表需要业务人员excel导入（订单履约主流程会判断候选人是否满足条件，填充赠品，赠品的数量不会太多）。

**如果附赠是劵**，需要向RocketMq中插入一条事务**消息**。

1.消费者系统：消费这条消息，把活动条件传给BI接口，获取到所有满足条件的用户（最多600W用户），将所有用户Id扔到线程池中，线程任务向RocketMq中插入一条**消息**（不批量是因为需要占库存）。

2.消费者系统：消息的消费者调用卡劵服务为用户绑定优惠劵，如果需要发送短信通知，则再发送一条事务**消息**（每一个用户一条消息，因为短信接口只支持单，不支持多）。

3.消费者系统：发送短信给客户。

根据所需的处理效率，创建不同数量的消费者，弹性伸缩。如双11晚上10点发放劵，扩充机器节点数。（华为云2C4G一个月200RMB+）

#### 弹窗领劵

弹窗领劵，用户在app上会弹出优惠劵，点击领取，调用绑劵接口。

2.当请求量非常大时，用户点击领取，先不绑劵，直接向RocketMq中插入一条事务**消息**。同2。

用户查看劵时再实时调用帮劵接口同步。

**后优化方案如下**

```
准备新建两个系统
1.营销活动（配置活动规则）
提供接口到前端，用户弹窗参加领卷活动
接口将劵记录落库后，把发劵的动作异步处理，使用双层本地队列处理，接口立即返回
一层队列缓冲"活动决策"是否通过
如果通过，放入本地二层队列
二层队列缓冲"营销资产系统"承载能力

补偿机制：job抓取处理30还未发劵的任务根据状态放入本地queue中
容器关闭补偿机制：spring容器关闭，通过更改信号使得queue的消费者知道容器即将关闭不再消费，把未处理的数据发送到MQ交由其他系统消化
2.用户资产（发放劵到用户账户）用户系统，包含用户资产信息
发放劵到用户账户里
劵的库存放入redis中，先做库存扣减再做劵的存表，尽可能防止超卖，如果存表失败需要加回redis库存，如果异常宕机加回失败则容忍
```

## 客服

客服系统的作用是售后的一些处理和辅助用户的动作，这里我简单分为两大类

### 非单据相关

如：解绑用户优惠劵、编辑短信发送用户、用户地址修改、补开发票、查看评论、恶意订单等

### 单据相关

单据相关的处理动作与订单系统正逆向紧密相连，也是客服系统比较重要的部分。

整个流程是job处理，因为是ToB，且单据都需要审核，不需要太强的**时效性**。

1. 订单拉回

   订单拉回是指，用户的订单可能存在没库存，或者需要更换地址，或者需要修改收货时间等等情况，此时需要把原订单推到待拉回列表，然后操作修改生成新的订单，原单结束掉。

   拉回分三种：1.拉回生成新订单 2.拉回缺货等待 3.拉回取消单

   主流程是订单正向处理，因为拉回动作不是逆向动作。只有3拉回取消单需要通知逆向系统取消。

2. 销退单

   销售退货是指，售后用户发现商品存在质量问题，退款或者退货退款（需要上门取货）。通知逆向系统处理。

3. 拒收

   拒收是销退的一种情况，也是以销退单的形式通知逆向。

4. 换退单

   销售换退单是指，售后用户发现商品存在质量问题，想换一个质量好的同品。换退单分为两个步骤，先销退掉（逆向），再生成新的发货单（正向）。

5. 补发单

   补发是指，漏发或者商品存在质量问题更换商品给用户发出。生成新的发货单（正向）。

**取消、销退、拒收**这三种情况需要通知逆向系统处理

## 逆向

订单逆向WS系统：提供接收三种逆向处理的接口（取消、销退、拒收）

本地事务插入成功后，提交一条事务**消息**，逆向的**询问**处理流程。

消费者系统：

oms_order_cancel_flow

1. 询问OMS正向，暂停OMS正向履约流程，如果未下发WMS，则不需要询问WMS。

2. 如果需要通知WMS或供应商则询问。

3. 如果是销退且需要上门取货，调用TMS分配快递。取消单则不需要。
4. 计算退款的金额。部分商品的订单销退需要分摊下退款金额。
5. 处理结束，填充通知其他系统的节点记录，写入oms_order_push表。这张表不是流式处理，而是并发处理，Cancal异步抓取binlog处理。

Cancal抓到oms_order_push表DML操作，根据工厂模式按类型找到指定的Worker，每个Worker存在自己的线程池，目的也是为了区分I/O密集型和CPU密集型，提交线程池执行。

节点处理完毕后，可能还有会后续操作，继续向oms_order_push表插入，Cancal继续抓取处理。

例如如下操作：

1.销退、拒收需要推送WMS

2.取消、销退、拒收需要推送FMS申请退款

3.推送数据给FMS，结算

4.推送数据给FMS，退款凭证

5.预售推送数据给可卖数维护（预售和极致新鲜）采销

6.产地直发采退单虚出

7.推送数据给请求者订单是否可以取消或退货

8.推送数据给可卖数维护

9.推送数据给TMS

10.解绑积分商城优惠券

......



## 第三方订单系统

### 销售计划

销售计划是为企业或第三方订单，也就是ToB，所提供的一种生单方式，这种订单不需要支付，按月、季、年来与B端企业结算收款。通过销售计划转换为春播订单。

销售计划的生成方式有两种：1.春播的销售人员手动在SSO下销售计划 2.**第三方订单**自动生成销售计划。

### 第三方订单

第三方订单指的是春播商品在第三方平台售卖，如：饿了么、美团、抖音、工行商城、有赞、**悦店**......

第三方订单取得的方式有两种：1.外网暴露的生单接口，等待对方调用（饿了么、美团、悦店...实时性要求比较高的） 2.job调取第三方接口抓单（抖音、有赞...实时性要求不那么高的）

接单写入``oms_third_order_process``表、``oms_third_order_main``表、``oms_third_order_detail``表，写入一条事务**消息**，消息的消费者为其生成销售计划，后再写入一条事务**消息**，消息的消费者为其生成春播订单。

使用RocketMq削锋解耦

悦店订单是团购模式，截团之后，会有大批量订单同一时间推送过来（几万单），使用Mq慢慢消费掉即可



# PAY

支付系统简述

## 支付正向

### 非现金支付

非现金指的是，使用春播app自己的支付方式支付，例如：余额、春播卡、春播券、积分、春播商品卡

用户下单时，前端先调用支付系统扣减非现金，成功后，再调用订单系统生单。

非现金扣减成功后，生成非现金扣减流水，并异步将实收推送到财务系统。

### 现金支付

生成订单后，跳转到春播的收银台，用户选择相应的支付渠道。此时前端会调用支付系统的两个系统接口：1.生成交易流水和渠道流水接口TradeGateway系统 2.跳转至第三方支付平台接口Clearing系统。

用户到第三方支付平台的收银台，操作付款，支付的结果我们有两种方式获取：1.job定时抓取支付结果 2.PayCenter系统等待第三方支付平台回调支付结果。

获取到支付结果后，需要向第三方支付平台再次验证结果是否正确。验证正确无误后：1.修改交易流水状态 2.通知OMS支付结果 3.推送财务系统支付实收。

## 支付逆向

### 非现金退款

同正向相反

### 现金退款

与正向相反。取消动作不需要财务审核，以外的退款需要推送财务系统，需要财务审核通过后再发送支付平台申请退款。



# WMS

ERP系统，企业资源计划（Enterprise Resource Planning）

WMS是基于Warehouse的一套ERP系统，对电商的资源起到管理作用。

WMS的核心有两个：1.**销单出库**  2.**实物库存管理**

## 销单出库

原来的出库流程都使用Job抓取，有的1min一次，有的5min一次

整个单据也是通过状态机驱动

1.接单

接单系统WS：接收OMS的订单

``order_header``、``order_detail``、``order_delivery``、``order_profiles``

本地表写入成功后，RocketMq发送一条订单拆单事务消息。

2.订单拆单

消息消费者系统：由于库房是基于温区作业的，要把订单，按照温区进行拆单。

一共5个温区：常温、高温冷藏、低温冷藏、高温冷冻、低温冷冻

其他的拆单规则如：独立成箱（大物件或者按原箱售卖的商品）、（蔬菜和包）

``sales_order``、``sales_detail``

本地表写入成功后，RocketMq发送一条订单占库存事务消息。

3.库存占用

消息消费者系统：以订单的维度对货位库存进行占用。常出现货位库存不足的情况，此时需要查看备货区是否有库存。

``prick_list_item``拣货表、``wms_inv``库存表（只占用不扣减）

4.作业单汇总

Web系统操作：库房负责出库的管理人员，会根据当前库房的作业情况进行作业单汇总，必须是同一快递，汇总成拣选单，供拣货人员到指定货位拣货。

拣选车-一次可以拣20个作业单

``pick_list_header``、``rf_task``、``pick_list_plan``

5.拣货下架

RF手持系统：拣货人员领取拣选单任务，根据拣货指引进行拣货。

拣货下架时会对``wms_inv``表扣减占用数和在货位库存数。

``rf_task``、``pick_list_progress``

6.订单质检

Web系统操作：拣货人员拣货完毕会把拣选车拉到质检打包区，质检人员扫描拣货车上的容器号，进行商品质检。显示作业单xxx需要xxx商品两个，在拣选车的哪个位置，质检人员扫描商品进行严格质量检查无误后，以作业单维度打包成包裹（可以有多个包裹）。

``box_header``、``box_detail``

7.订单称重

Web系统操作：如果作业单所属的快递，是需要称重的，需要进行称重

8.订单批次交接

Web系统操作：大仓每日凌晨，快递车来取快递，此时对这些包裹生成批次交接单。

``order_hander_over_header``、``order_hander_over_detail``

**至此，库房完成出库**

本地表写入成功后，RocketMq发送一条导入TMS事务消息。

9.包裹导入

消息消费者系统：将包裹数据导入到TMS当中。



### 部分出库

需求背景：质检人员质检商品发现商品的质量不行，联系管理人员更换，如果此时库房不存在实物了，这个包裹将无法出库直至再次采购收货有实物。
现想将有库存已打包好的商品优先出库，故开发部分出库。
功能简述：
1.订单质检页面，拣选单内作业单质检时，点击质检确认按钮，保存拣选单内差异作业单记录，发生实物报缺
2.订单质检页面，拣选单容器号处输入作业单号，可进行二次质检
3.如果二次质检作业单时，作业单内仍存在缺失商品，点击质检确认，录入详细实物报缺情况，点击确认进行报缺重检确认
代码位置：SalesOrderReportDeficiencyReQcImpl.java#reportDeficiencyReQcConfirm();
需求难度：
1.质检涉及的表非常的多，开发需要考虑的点就会非常的多。
2.还需要考虑零售店补货单的多种情况，使开发的复杂度更大。
PS：由于零售店不是春播的公司，需要结算对账，所以无法下调拨单调货。无锡的零售店补货单会转换为销单，进行质检出库
零售店补货单需要校验“起订量”，如：10个起订，不足10个的部分需要上架回去

设计模式：简单工厂、责任链、建造者、包装器、适配器、模板方法
责任链链条主要有：虚拟数量出库质检（出库数量为订单上的数量）、实际数量出库质检（出库数量为实际质检了的数量）、建造损废单、建造损废单及流水、建造rf上架任务及随机占批次、建造rf上架任务及按规则占批次、统一事务操作执行器、上传客服异常信息（开启多线程执行）
1.	标准虚拟出库任务链条：生成损废单->虚拟出库质检->插库事务->上传客服
2.	零售店补货单部分出库生成损废单链条：生成损废单及流水->实际出库质检->插库事务
3.	零售店补货单部分出库生成损废单并含未出库商品回架生成RF上架任务链条：生成RF上架任务->生成损废单及流水->实际出库质检->插库事务
4.	零售店补货单部分出库生成RF上架任务链条：生成RF上架任务->实际出库质检->插库事务
清晰拆分，代码可读性高，可扩展性高
如果后续销单要走按实际数量部分出库，且上传客服系统，前端只需要增加一个serviceId标识业务类型，后端只需要接收业务类型、在工厂内增加一条相对应的责任链即可，无需修改代码

## 实物库存管理

``wms_zone``库区、``wms_inv``批次库存、``inv_tran``流水记录上传ERP库存





# 分布式技术总结

## 数据一致性

多系统通信，数据一致性是很常见的问题

### 强一致

场景如：1.接单中的订单系统与库存系统 2.拉回时的订单系统、WMS、TMS

**现在的做法**：在本地事务的末尾，调用需要一致的系统，如果系统返回失败，则抛异常回滚，如果系统返回成功，则事务提交。

该做法不能完全保证事务强一致，有可能系统返回成功，但是事务提交失败。

**优化的做法**：使用Seata框架的AT模式，保证多系统的分布式一致性

### 最终一致

1.使用RocketMq事务消息同步数据

2.使用本地异步同步表, Job抓取同步数据

如: 库存流水的同步, 订单数据异步同步财务系统......

3.Canal伪装成Mysql的Slave节点, 抓取binlog同步数据

如: 数据库新增记录后, 需要同步到Bloomfilter.

## 分布式锁

如果是数据库操作, 可以使用Innodb的锁.

但如果使用Mysql中尚未存在的数据做判断条件, 如:结算单号, if (**库中不存在某记录**) {某种处理逻辑} 

一定要使用带超时时间的lock方法, 如果超时仍未获取到锁, 整个方法返回失败, 不允许向下执行

## 分布式缓存

Redis

Bloomfilter: 布隆过滤器

应用场景: C端用户查看订单详情时, 需要调用客服系统的取消申请表查看是否存在取消申请, 如果存在那已经到了哪个步骤

但取消申请表, 每100单可能存在1单取消申请, 绝大多数情况客服系统的取消申请表是不存在记录的, 导致下午峰值访问时, 订单系统读取客服系统超时异常报警.

使用布隆过滤器, 将取消申请表的orderId放到过滤器中, 接口请求先校验过滤器是否存在, 存在在读表. 解决了这个问题